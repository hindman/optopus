--------------------------------------------------------------------------------
argle-notes: Content, tasks, and development notes
--------------------------------------------------------------------------------

--------
toc: Table of contents
--------

    argle-notes | Content, tasks, and development notes

        toc       | Table of contents
        todos     | TODOs
        new-notes | New notes
        road-map  | Road map
        dev-notes | Dev notes

    specification | Specification

        spec-syntax            | Spec syntax
        syntax-examples        | Syntax examples
        terminology            | Terminology
        classes-and-attributes | Classes and attributes

    discussion | Discussion

        name: str
        api-vs-text                    | API-driven vs text-driven
        other-lib-weaknesses           | Addressing weaknesses common in other libraries
        other-goals                    | Other goals
        standard-cli-grammar           | Standard command-line grammar
        cli-grammar-vs-regex           | Command-line grammar vs. regex
        subparsers-not-needed          | Argle does not need the subparser concept
        opt-action-not-needed          | Argle does not need the action concept
        explicit-var-input-syntax      | Why explicit syntax is needed for variable inputs
        variable-input-spec            | Spec for variable input
        opts-revised-OO-plan           | Revised OO plan for Opts and child elements
        groups-can-be-parameters       | Options can have Groups as parameters
        parser-config-api              | Parser.config() API
        opt-and-arg-configuration      | Configuration of Opt and Arg
        help-text-formatting-and-api   | Help text formatting and API
        spec-parsing-general-approach  | Spec parsing: general approach
        arg-parsing-algo               | Parsing algorithm
        alternative-parsing-algo       | Alternative parsing algorithm won't work after all
        ambiguous-grammars             | Ambiguous grammars are not an issue
        opt-choices-vs-choice          | Opt.choices vs Opt.choice
        opt-independence               | Opt independence, duplicate names/dest, and opt-spec scope
        parsed-data-structure          | Parsed data structure
        parsed-data-with-context       | Including Context with the Result
        eager-attachment-at-bounary    | Eager option attachment at repetition boundaries
        spec-syntax-named-unnamed      | Spec-syntax: named and unnamed arguments
        variants-needed                | Variants: why they are needed
        general-name-assignment        | General name assignment: needed after all
        spec-syntax-complexity         | Spec-syntax: is it too complex?
        optional-positional-placement  | Optional positionals before required are not a problem
        parsing-modes                  | Parsing modes
        zones-not-needed               | Zones not needed
        dispatch-to-callables          | Dispatching to callables
        prompting-for-var-inputs       | Prompting end-user for var-inputs
        confirmation-option            | Supporting confirmation options like --yes
        argparse-and-greed             | argparse and greediness
        end-user-errors                | End-user errors
        converters-validators          | Converters and validators
        grammar-querying-api           | Grammar querying API
        validation-notes               | Validation notes
        strategy-reassessment          | Reassess the strategy
        opt-spec-subset-of-spec-syntax | Opt-spec syntax is a subset of the spec-syntax
        help-text-as-format-strings    | Help text elements as format-strings
        var-input-representation       | Representing var-inputs in spec-syntax
        enhanced-quantifiers           | Enhanced quantifiers
        opt-specs-and-opt-descs        | Opt-specs and opt-descs
        group-level-validation-needed  | Why Group-level validation should be retained
        usage-section-spec-syntax      | Usage section in the spec-syntax
        usage-text-and-named-groups    | Usage-text and named groups or choices
        headings-in-spec-syntax        | Spec-syntax support for headings
        arg-choices-in-usage-text      | Arg.choices in usage-text
        groups-need-names              | Why Group needs both dest and name
        degenerate-groups              | Degenerate groups with only one element
        settings-and-opts              | Opts and settings (preferences and environment variables)
        parser-serialization           | Parser serialization
        man-pages-and-argle            | Argle and man-pages
        readme-next-version            | README for next version

    reference | Reference

        parsing-resources                | Parsing resources
        parsing-process-generally        | Parsing process generally
        pegs-cfgs-and-packrat-parsing    | PEGs, CFGs, and packrat parsing
        grammar-types                    | Grammar types
        other-tools                      | Other tools
        problems-scenarios-from-argparse | Problems scenarios from argparse
        example-grammars                 | Example grammars
        argparse-problems                | Examples of problems with argparse
        project-name                     | Project name: history and alternatives

--------
todos: TODOs
--------

Spec-parsing [see grammar.py for todo list].

Argument parsing.
    - Read arg-parsing-algo

Generate basic usage and help text.

Docs: proper README [see readme-next-version].

Upgrade classifers to beta.

setup.py:
    - Drop.
    - Move metadata to pyproject.toml
    - See: https://chatgpt.com/c/681fb756-3b08-8003-b89c-c4e070fe87bc

tasks.py:
    - task to create and push a tag

Slogan ideas:
    https://chatgpt.com/c/681f862c-f714-8003-a9ed-33242056c155

Release.
    - Maybe drop tox.
    - Set up Github Actions.
    - Support nothing older than 3.7
        3.6 : f-strings added
        3.7 : dicts ordered
    - Current status:
        3.7: end of life
        3.8: end of life
        3.9: nearly there

Plan next release:
    - Edit road-map.

--------
new-notes: New notes
--------

...

--------
road-map: Road map
--------

** Ordering in this section:
    - Much of the ordering seems questionable.
    - Revisit after achieving the core behaviors.

Arg configuration:

    - Convert.

    - Validate.

    - Choices.

    _ Factory.

    - Utility types: Path, File, etc.

Parsing enhancements:

    - No-args behaviors, such as show-help or default-args.

    - Data flattening/non-flattening in Result.

Help text: enhancements:

    - Help text: show defaults and choices.

    - Help text: sections.

Alternative inputs: basics:

    - Aliases.

    - Tight binding of option and parameter: --opt=<param>

    - Short-flag bundling.

    - Option-prefix customization.

    - Quoting customization.

    - Non-option args having option prefix: negative numbers.

    - Non-option args having option prefix: configurable escape prefix.

    - Negaters.

Project health:

    - Add validation to user-facing callables.

    - Documentation.

    - Docstrings.

    - Github Actions for CI.

Alternative/fuzzy inputs: handy:

    Abbrevations for long-options.

    Abbrevations for choices.

    Case-insensitivity for options and choices.

Dispatching:

    General dispatch.

    Help dispatch.

    Different dispatch for --help vs -h.

Grammar enhancements:

    Priority options.

    Anchored Opts.

Parser enhancements:

    Parser.query() and bulk configuration.

    Parser utilities: warn(), help(), error(), exit().

    Parser configuration to add single-letter option aliases automatically.

    Group validation.

Alternative inputs: other:

    @FILE (command line arguments from a file). See argparse fromfile_prefix_chars.

    Case-insensitive options.

    Support prompting for inputs (eg password).

Text customization:

    Help text: short options in separate section.

    Help text: usage: symbolically named groupings.

    Help text: customizations via config and/or hooks.

    Help text: supplied via alternative devices (text file or blob, with
    f-string support).

    Error text: customizations via config and/or hooks.

    Man-page-style help text.

Development aids:

    Hidden options: either totally or in specific types of help text.

    Automatic --version.

    Ability to emit Parser configuration as data (and re-create from data).

    Bash completion.

    Integration with configuration data (user prefs) and environment variables.

Other possibilities:

    Enhanced quantifiers: range-step and disjoint values.

--------
dev-notes: Dev notes
--------

Creating a new virtualenv:

    v='3.9.4'
    p='argle'
    deactivate
    pyenv shell $v && pyenv versions
    mkvirtualenv $p-$v
    pip install -U pip
    pip install -e .[dev,test] && pip list

Activate and run tests:

    - Basic:

        workon argle-3.9.4
        pytest -s -v tests/

    - With invoke:

        inv test
        inv tox

    - With tox directly:

        pyenv shell 3.9.4  3.8.9  ...
        tox

Version bump:

    - Edit/commit all changes, including CHANGES and README.

    inv bump --kind major|minor|patch

Publish:

    inv dist [--publish] [--test] [--verbose]

Installing from test pypi:

    pip install --index-url https://test.pypi.org/simple/ argle
    pip uninstall short-con
    pip install short-con

Tag file creation:

    inv tags

--------------------------------------------------------------------------------
specification: Specification
--------------------------------------------------------------------------------

--------
spec-syntax: Spec syntax
--------

spec:

    [usage-section]
    [section...]

usage-section:

    [variant...]
    [section-content-elem...]

section:

    [any-section-title] ::
    [section-content-elem...]

any-section-title:

    section-title | scoped-section-title

section-title:

    title-text ::

    - Text and marker must be on one line.

scoped-section-title:

    section-scope >> section-title ::

    - A section-scope applied to a section is a shortcut for applying the scope to
      all opt-specs within the section (details below).

section-scope:

    query-path >>

query-path:

    query-elem [. query-elem]...

query-elem:

    glob-char... | digit...

    - Can be a name/dest glob pattern or a positive integer.
    - Glob pattern uses: valid-name characters; and wildcards (? and *).

section-content-elem:

    [heading | opt-spec | block-quote]...

heading:

    heading-text :::

    - The heading-text must be on one line.
    - The marker must end the line.

block-quote:

    opening-triple-quote quoted-text ```

    - Where opening-triple-quote:

        ```  | .
        ```! | no wrap
        ```# | spec-comment

        - Triple-quotes can sit on their own line, or not.

    - Where quoted-text:

        - Can span multiple lines.

variant:

    [valid-name[!] :] variant-def

    - Marker (!) means partial-variant.

opt-spec:

    [[opt-scope] >>] opt-spec-def [: [opt-help-text]]

    - If Opts are declared in variants and later in opt-specs, the two
      configurations are merged:

        - Opt-spec configuration is connected to the relevant Opt from the
          grammar (see opt-independence for details).

        - Opt declared in the grammar can use an abbrievated form (an
          opt-mention), leaving the full configuration to the opt-spec.

    - An opt-scope has the same format as a section-scope. The only difference
      is that an opt-scope can be empty (marker only).

    - The opt-scope marker (>>) declares a parent-child relationship.

        - With a opt-scope:
            - Parent: Opt from variants.
            - Child: current opt-spec.
            - Declares the Opt to which the opt-spec should be connected.

        - Empty opt-scope:
            - Parent: preceding (non-scoped) opt-spec.
            - Child: current opt-spec.
            - Child configures an Arg or Choice of the parent.

opt-spec-def:

    opt-spec-group | opt-spec-elem

opt-spec-elem:

    positional | aliases-and-option

opt-spec-group:

    (opt-spec-elem)
    [opt-spec-elem]

    - The group cannot be named.
    - It only function to support a quantifer.

python-name:

    first-char char...

    - Where:
        first-char | letter, underscore
        char       | letter, underscore, digit

valid-name:

    - Just like python-name, but char can also be a hyphen.

    - Consistent with argparse, hyphen and underscore can be combined,
      adjacent, at the end. Insane but valid: --__foo-_-fubb-_

opt-help-text

    - The rest of the line, plus continuation lines.
    - Colon marker without opt-help-text can be used to distinguish opt-spec
      from variant (to avoid ambiguity).

variant-def:

    variant-elem...

variant-elem:

    (
        option |
        positional |
        any-group |
        quoted-literal |
        partial-usage |
        choice-sep
    )

    - All take a quantifer except:
        - choice-sep (|)
        - quoted-literal
        - partial-usage (user can wrap in a group).

variant-elem: examples with comments:

    - Options:

        -f             # Short.
        -abc           # Bundled flags: -a -b -c.
        --foo          # Long.
        --age <yr>     # Long with parameters (groups can be parameters too).

    - Positionals:

        <bar>          # Single.
        <path>...      # With quantifier.

    - Quoted literals:

        `hello`        # Becomes a Literal, a limited form of Opt.

    - Groups and alternatives:

        ()             # Group.
        []             # Group, optional.
        foo=()         # Named group.
        foo=[]         # Named group, optional.
        |              # Alternatives separator.

    - Partial:

        foo!           # Insert foo partial into the variant.

    - Quantifiers:

        ...            # Either 1+ or 0+ (latter if the entity is optional).
        {m,n}          # Repetition: m through n, inclusive.
        ?              # Non-greedy for preceding quantifier.

quantifer:

    triple-dot[?]
    quant-range[?]

    - Where triple-dot:

        ...

    - Where quant-range:

        {min,max}
        {min,}

        - Both are positive integers.

    - Where ? marker:

        - Makes preceding quantifier non-greedy.

quoted-literal:

    ` text `

    - Does not support: name, dest, or quantifier.
    - Use backslash to get a literal backquote.

partial-usage:

    valid-name!

any-group:

    named-group | group

named-group:

    valid-name = group

group:

    ( variant-elem... )
    [ variant-elem... ]

aliases-and-option:

    [alias...] option

    - Where alias = bare-option.

bare-option:

    - first-char
    -- valid-name

    - Where first-char is a valid first character in a valid-name.

option:

    bare-option [any-parameter...]

any-parameter:

    parameter | parameter-group

parameter:

    < valid-name >
    < valid-name = choices >
    < choices >
    < >

choices:

    choice [ | choices ]

choice:

    valid-name | quoted-literal

parameter-group:

    ( parameter... )
    [ parameter... ]

positional:

    < valid-name >
    < valid-name = choices >

opt-mention:

    - A term/concept more than a parsing element.
    - Consists of Opt.name, with appropriate punctuation.
    - Examples:

        <foo>
        --bar
        -b

var-input:

    - Variable input provided by the user.
    - Primarily an internal term, not user-facing.
    - Forms: positional and parameter.

Whitespace rules:

    - Line and indentation requirements:

        - Opt-spec must start on its own line.

        - Variant must start on its own line.

        - Opt-spec and variant continuation line must be indented more than the
          first line and be contiguous with it.

        - Section title must be on its own line, ending in marker.

    - Line breaks not allowed:

        - Within an {m,n} quantifier.

        - Between a name and equal sign.

        - Within a var-input.

    - Whitespace not allowed:

        - Between option prefix and its name.

        - Between partial name and its exclamation mark.

        - Around equal size for named groups.

        - Within a triple-dot quantifier.

    - Whitespace is allowed:

        - Between an element and its quantifier (looks odd, but still valid).

--------
syntax-examples: Syntax examples
--------

pgrep: README example-1: EX_README_1

    - See argparse-vs-argle/pgrep-1-bare-bones

pgrep: README example-2: EX_README_2

    - See argparse-vs-argle/pgrep-2-basic

pgrep: README example-3: EX_README_3

    - See argparse-vs-argle/pgrep-3-enhanced

pgrep: README example-4: EX_README_4

    - See argparse-vs-argle/wrangle

Parser configuration: spec-vs-API: EX_JOB_CLIENT

    See misc/examples/spec-vs-api/job-client-*

blort: EX_BLORT

    - See misc/examples/argle-mock-ups/blort.py

    - A subcommand-style script.
    - Includes a full spec and the resulting usage-text.
    - Plus bells and whistles to exercise most of the spec-syntax.
    - Includes Opts with same-name and different-config.
    - Several notes to document the spec syntax and behaviors.

neck-diagram: EX_NECK_DIAG

    - This is a non-standard command line program: its grammar consists of one
      or more subcommands with a literal separator between them.

    cmd! :  command=(
                <cmd=snum>   <snum>             |
                <cmd=fnum>   <fnum>             |
                <cmd=number> <numbering=on|off> |
                <cmd=tuning> <notes>...         |
                <cmd=fret>   <syms>...          |
                <cmd=invert> <syms>...
            )

    main : cmd! [ `/` cmd! ]...

nab: EX_NAB

    - Another separator-based grammar.

    chomp!   : / <cmd=chomp>
    findall! : / <cmd=findall> <rgx> [-a]
    grep!    : / <cmd=grep> <rgx> [-i] [-v] [-s]
    range!   : / <cmd=range> <start> <stop> [<step>] [-g]
    run!     : / <cmd=run> <code> [-g <>] [-a] [-v] [-i]

    main : [--trace] commands=(chomp! | findall! | grep! | range! | run!)...
    help : --help

repo:

    - A comparison of Click and Argle for a subcommand program.
    - Illustrates several API details.

    - click-repo.py
    - argle-repo.py

naval-fate:

    - A comparison of Docopt, Click and Argle.

    - click-naval-fate.py
    - argle-naval-fate.py
    - docopt-naval-fate

API-driven configuration vs text-driven configuration:

    - See misc/examples/spec-vs-api/

    - Simple programs.
        get-pocket-items
        daily-reading

    - More complex examples.
        job-client-*

--------
terminology: Terminology
--------

Library:
    - The argle code base.

Users:

    user         | Software developer using argle
    library-user | Ditto.
    end-user     | Someone running a program that uses argle

Command line arguments:

    - Arguments:
        - The raw strings directly from the command line.

    - Positionals:
        - The typical non-option argument.

    - Options:
        - Arguments with an option prefix.

        --path    | Long prefix
        -p        | Short prefix
        ----------------------------------------
        -c <code> | Parameter option, or just option
        -y        | Flag

    - Parameters:
        - Arguments for an option.

Help text:

    Text        | Description
    ------------------------------------------------------------------
    Help text   | Full output from --help.
    Usage text  | Just the command-line grammar.
    Opt listing | List of Opts and their help text, perhaps in sections.
    Other text  | Written by user (default: wrapped by argle).
    ------------------------------------------------------------------
    Opt desc    | Help text for a single Opt

Spec:
    - More formally: parser-spec.
    - A Parser specification.
    - Text blob defining Parser's grammer, Opts, help sections, and text.

Spec-syntax:
    - Syntax used to define a spec.

Section:
    - Section of the spec and thus of the help text.
    - Has a title.
    - Can have text generated by argle (usage text and opt text) as well as
      text written by the user.

Usage-section:
    - The first section.
    - Will contain the generated usage text.
    - Default title: 'Usage'.

Variant:
    - A usage variant, as defined in a spec.

        [name :] variant-def

    - Examples:

        grep  : <cmd=grep>  <rgx> [-i] [-v]
        split : <cmd=split> [<rgx>] [-n <max>]

Variant-def:
    - The grammatical portion of a variant definition.
    - The stuff after the colon.

Argument-variant: positional-variant and parameter-variant:
    - Also: arg-variant.
    - Variant defined/triggered by a specific positional/parameter value.
    - See variant examples (above).

Opt-spec:
    - A portion of a spec defining one Opt.

Spec-spope:
    - A scoping declaration to connect an opt-spec or an entire section of
      opt-specs to a specific Opt implied by the usage grammar.
    - Also a way to declare an opt-spec that configures a child-element of a
      preceding opt-spec.

Var-input:
    - Var-input:
        - Stands for variable input.
        - Mainly for internal use in the Argle project.
    - User-facing terms:
        - positional
        - parameter

Literal-input:
    - Element of grammar requiring end-user to provide a literal value.
    - Examples:
        - The separator in a separator-based grammar: EX_NECK_DIAG.
        - In a subcommand-style program:
            - Each subcommand is an Arg.choice.
            - In usage-text, each variant uses a choice as a literal-input.

Anonymous-input:
    - A nameless var-input.
    - Example: --age <>

Name:
    - Symbolic name in help-text (for positional, option, or parameter).
    - Symbolic name in spec/API (for variant, section).

Dest:
    - Attribute name in Result for data from one positional/option.

Block-quote:
    - Triple-quoted literal help text.
    - With or without wrapping by Argle.

--------
classes-and-attributes: Classes and attributes
--------

Overview:

    - User-facing entities:

        Parser
        Section
        Grammar
        Variant
        Group
        Opt
            Positional
            Option
            Literal
        Arg
            Argument
            Parameter
        Choice
        Result
        Query

    - Relationships among user-facing entities:

        Parser
            sections      = List[Section]      # 1+   # Usage exists even with spec=''
            grammar       = Grammar            # 1    # Ditto.
                variants  = List[Variant]      # 0+
                    elems = List[Group or Opt] # 0+

            parse(ARGS) -> Result

        Group:
            elems = List[Group or Opt]         # 0+

        Opt:
            elems = list[Argument or Parameter]

        Arg:
            choices = list[Choice]

    - Objects used during spec-parsing:

        SpecParser | Parses a spec, returns Grammar.
        RegexLexer | Lexer used by SpecParser.
        TokType    | Token types given to lexer.
        Token      | Emitted by lexer.
        ParseElem  | Emitted by parser functions. Later assembled into Grammar.

    - Objects used during argument parsing:

        State
        ArgResult
        Target

    - Entities used only for notation:

        PartialUsage      | Group
        Positional        | Opt
        PositionalVariant | Opt
        ParameterVariant  | Opt

Parser:

    - Class will likely have various getters or query functionality to make it
      easy to configure specific grammar elements. Users should not have to
      manually navigate the Grammar hierarchy.

    - Attributes:

        # The grammar.
        spec: str
        grammar: Grammar
        sections: list[Section]

        # Typically inferred by Argle.
        prog: str

        # Parsing mode: regular or no-config [maybe others later].
        mode: str

        # Namespace to hold help-text formatting defaults/behavior.
        # Deferred for now.
        format: HelpTextFormat

    - API:

        - Notation:

            p = Parser(SPEC)

        - Parsing:

            p.parse(args = None, mode = ...)

            - Returns a Result or raises.
            - The method can temporarily use a different mode than the Parser.mode.

        - Querying grammar elements:

            - See grammar-querying-api

            p.query(*paths, **kws) => Query

        - Configuring grammar elements:

            - See parser-config-api

        - Configuring one attribute across multiple elements:

            p.query(*paths).config_each(attr_name, **kws)

            - Convenience method to set an attribute across multiple elements.

        - Obtaining help text or text for the error from most recent parse():

            p.help_text(section...)
            p.error_text()
            p.exception()

        - Actions like printing or exiting.

            p.warn(msg)
            p.help(section...)
            p.error(msg = None, code = 1)
            p.exit(msg = None, code = 0)

Section:

    - Used to create labeled groups of Opt for help text purposes.

    - Attributes:

        # Symbolic name used in API.
        name: str

        # Section title in help text.
        title: str

        # Section content.
        # - Opts belonging to the section.
        # - Hand-crafted help text (probably needs more modelling).
        opts: list[Opt]
        text: str

Grammar:

    - Attributes:

        variants: list[Variant]

    - API:

        - See grammar-querying-api

Query:

    - Sequence object returned by Grammar.query().
    - Holds the Grammar elements satisfying the search parameters.
    - Supports bulk configuration.

    - Attributes:

        elems: list[Group or Opt or Arg]

    - API:

        - Notation:

            p = Parser(...)
            q = p.query(...)

        - Apply configuration to grammar elements.

            q.config(...)

        - Subquery to filter down further:

            q.query(...) => Query

Quantifier:

    - Might be a concept rather than an object.
    - Represents any valid input value for nargs or ntimes.

        N
        (N, M)
        (N, None)

Variant:

    - Attributes:

        name: str .
        elems: list[Group or Opt]
        ntimes: Quantifier

Group:

    - Represents spec-syntax enclosed by brackets.
    - Primary purposes:
        - Ability to quantify groups of grammar elements.
        - Mutual exclusion for such groups.
        - Using the dest to organize nested Result data.
        - Using the name to represent groups of Opts symbolically
          in usage-text.
        - Ability to apply validation to groups of Opts.

    - Attributes:

        # Name and dest:
        # - name comes from the spec.
        # - dest defaults to name.
        # - If name is set, it is used to represent the
        #   group in usage-text.
        name: str
        dest: str

        # Quantifier and group-level validation.
        ntimes: Quantifier
        validate: callable

        # Mutual exclusion: true for groups defining alternatives.
        mutex: bool

        # Child elements.
        elems: list[Group or Opt]

Opt and children: overview:

    - Base classes: an Opt has 0+ Args:
        Opt
        Arg

    - Opt kinds and their Arg kinds:
        Positional
            Argument
        Option
            Parameter
        Literal
            None

Opt:
    - Base class for Positional, Option, or Literal.
    - Some of the common attributes listed for each subclass (below) might be
      implemented at the Opt level (TBD).
    - Also see: opt-and-arg-configuration

Positional:
    - Subclass of Opt.

    - Attributes:
        spec: str
        name: str
        dest: str
        help: str
        nargs: Quantifier
        ntimes: Quantifier
        elems: list[Argument]
        --
        hide: bool
        anchor: bool
        dispatch: list[callable]

Option:
    - Subclass of Opt.

    - Attributes:
        spec: str
        name: str
        dest: str
        help: str
        nargs: Quantifier
        ntimes: Quantifier
        elems: list[Parameter or Group]
        --
        hide: bool
        anchor: bool
        dispatch: list[callable]
        --
        aliases: list[str]
        priority: bool                   # Flags only.
        negaters: list[Option]

Literal:
    - Subclass of Opt.

    - Attributes:
        spec: str         # The literal value (no backquotes).
        anchor: bool      # Always True.

Arg:
    - Base class for a variable-input as a configurable unit.
    - Sub-classes: Argument or Parameter.
    - Also see: opt-and-arg-configuration

Argument:
    - Subclass of Arg.
    - No name and no dest.

    - Attributes:
        spec: str
        help: str
        ntimes: Quantifier
        choices: list[Choice]
        default: object
        factory: callable
        convert: callable
        validate: callable

Parameter:
    - Subclass of Arg.

    - Attributes:
        spec: str
        help: str
        ntimes: Quantifier
        choices: list[Choice]
        default: object
        factory: callable
        convert: callable
        validate: callable
        --
        name: str
        dest: str

Choice:
    - Attributes:
        spec: str      # The literal value.
        help: str

Result:

    - Data object returned to end-user by Parser.parse().

    - An iterable mapping-like object with destinations as the attributes.

    - In more complex grammers the top-level Result returned by parse() might
      contain nested Result instances (eg, a Group with a quantifier of 2+).

SpecParser:

    - Attributes:

        lexer     | Lexer.
        handlers  | Sequence of token-stream handlers.
        curr      | Managed by the mixin.
        prevpeek  | .

    API:

        parse()
        eat()
        error()

RegexLexer:

    - General-purpose regex-based lexer.

    - Attributes:

        text      | The text to be lexed.
        toktypes  | Sequence of TokType.
        pos       | Current index of the lexer.
        mxpos     | Last index of the text.
        iseof     | Becomes True when text exhausted.

    - API:

        See old.py implementation and modifications in draft.py.

TokType:

    - Internal data object given to a lexer.

    - Attributes:

        name  | Name of token.
        regex | Regex to match the token.
        emit  | Whether to emit back to parser [default: True].

Token:

    - Simple internal data object emitted by a lexer.

    - Attributes:

        toktype | TokType of the token.
        value   | Corresponding token text.
        pos     | Position (where matched)
        line    | Line number.
        col     | Column number.

    Kinds:

        Same as TokType.

ParseElem:

    - Simple internal data object emitted by the parsing phase of
      SpecParser.parse(). Subsequent work in that method will convert the
      ParseElem into a user-facing Grammar.

    - Attributes for each kind of ParseElem will vary.

    Kinds:

        variant
        group
        opt
        quantifier
        choices
        parameter
        literal

State:

    - An internal data object used during argument parsing. See
      arg-parsing-algo notes.

ArgResult:

    - An internal data object used during argument parsing. See
      arg-parsing-algo notes.

Target:

    - A data object used during argument parsing to store the information
      ultimately returned as a Result to end user.

    - For the applicable parsing interpretation, a Target contains information
      about all relevant Opt/Pos and values parsed so far.

    - Attributes:

        poss | List[Pos]
        opts | Dict[Opt]
        vals | Dict[DEST -> VAL]

--------------------------------------------------------------------------------
discussion: Discussion
--------------------------------------------------------------------------------

--------
api-vs-text: API-driven vs text-driven
--------

Two fundamental configuration strategies for argument parsers:

    - API-driven:

        - User configures a parser via the programmatic API.
        - The parser generates the help text.
        - Typically allows user to override with literal help text, if desired.
        - Examples: argparse and many others.

    - Text-driven:

        - User writes usage and options text.
        - Library derives the parser from that text.
        - This approach is much less common.
        - Examples: docopt.

The argle library combines the best of both approaches:

    - API-driven.

        - Tends to require less typing for a variety of configuration tasks
          (but not all; see below).

        - Generated usage text is mostly fine, especially for simpler projects.

        - Most developers probably prefer an API-driven approach over
          hand-formatting help text themselves.

        - API-generated help text will follow the conventions for documenting
          command-line programs -- conventions that few developers have studied
          in depth and would rather not worry about.

        - API-generated help text can be wrapped to the current terminal width.

    - Text-driven for grammar and naming:

        - Even though my experiments configuring argument parsers of varying
          complexity via usage text convinced me of the benefits of an
          API-driven approach, text-driven argument parsers have notable
          advantages.

        - Those advantages are focused in a few core areas:

            - The command-line grammar.
            - The associated naming for entities in that grammer.
            - And thus the naming for the parsed data returned to the caller.
            - The configuration elements that are inherently textual:
                - Help text for each positional or option.
                - Other help text.

        - The text-driven approach (and the related focus on command-line
          grammar) leads one to emphasize the idea of usage variants, a
          technique that can greatly enhance usage-text readability --
          especially for complex programs but also for small ones.

            git diff [<commit>] [--] [<path>...]
            git diff --cached [<commit>] [--] [<path>...]
            git diff <commit> <commit> [--] [<path>...]

            frob [--debug] [--foo <f>] <path>...
            frob --help
            frob --version

        - Usage variants open up a range of possibilities in the kinds of
          command-line grammars that can be supported.

            - API-driven parsers struggle with command-lines that need any
              grammar falling beyond the most typical cases.

            - On stackoverflow and bugs.python.org, for example, one can find
              many command-line use cases (some of them quite simple) that are
              not supported easily by argparse but that are straightforward in
              docopt.

        - Finally, usage syntax is both efficient and intuitive.

            - When internet users discuss command-line grammar scenarios, they
              invariably use a usage syntax to specify the desired grammar.

            - In my own research, I experimented with defining the needed
              grammars via an API, but I consistently found the text-based
              approach simpler to express and read.

            - For a good example, see this argparse discussion where a user
              describes a problem in general terms and suggests how the
              argparse API could be augmented to handle such cases.

                - The discussion is somewhat difficult to understand without
                  very careful reading and thinking.

                - Then the user provides a short one-line usage syntax, and the
                  issue is immediately clear.

                - See https://bugs.python.org/issue11588

Configuration via usage syntax is focused on grammar:

    - Argle keeps that syntax fairly clean, readable, and intutive by
      focusing it solely on the grammar and naming -- the area where it excels.
      Almost all other details, if any are neeeded, are handled via the API.

    - The syntax is also intuitive because it relies heavily on common
      conventions for documenting command-line programs.

    - The syntax will look roughly like familiar usage text, plus a small
      number of additional syntax elements focused on supporting flexible
      command-line grammar.

        - Usage variants. Discussed above.

        - Partial variants, which use the variant concept to define a named
          group of options and/or arguments that can then be inserted into one
          or more usage variants -- avoiding repetition in the definition of
          complex grammars (argparse does something analogous via parents).

        - The ability to attach names to any elements in the grammar.
            - Those names become symbolic handles to represent the entity in
              the generate usage-text.
            - Indirectly, the also indicate the ultimate stored destination for
              the parsed data from the named entity.

    - The syntax opens up a wide range of possibilities for complex programs or
      unusual grammars.

    - But it also simplifies configuration of argument parsing for the simplest
      cases.

    - And it also helps at the micro scale: simplifying the configuration of
      individual options.

--------
other-lib-weaknesses: Addressing weaknesses common in other libraries
--------

Providing users with simple ways to handle command-line grammars and usage
variants (noted in a previous section).

Supporting everything from quick-and-dirty scripts to complex, highly
customized command-line programs:

    - At once extreme, argle allows you to parse any default-behavior
      command line, with zero configuration. Just import and go. This parser
      won't enforce any rules, but it will tell you what the end-user entered
      -- which is good enough for many types of quick-and-dirty scripts,
      debugging sessions, experiments, and even early prototypes.

    - At the other extreme, you could build the next Git or a variety of
      programs with idiosyncratic grammars, heavily customized help text, and
      many other features.

    - Sitting between the two extremes are numerous conveniences and sensible
      defaults to make option parsing easy, no matter what level of control
      your application needs.

Allowing users to control the generated help text in a fine-grained manner.

    - Program complexity increases the need to organize and fine-tune help
      text, but not necessarily to write and layout the whole thing
      (text-driven libraries require the latter).

    - Argle provides many mechanisms for that fine tuning:

        - Simple top-level configurations to control basic layout,
          capitalization, punctuation, etc.

        - Ability to group options into sections.

        - Ability to supply hand-crafted sections whenever needed and to locate
          those sections with precision in the output.

        - Ability to control nearly all parameters driving the help text
          contruction process via configuration and, where necessary, through
          the programmatic hooks. There should be no need to subclass argle
          or delve into the parser's innards.

        - Support for common styles: command-line vs man-page.

Allowing users to enhance usage-text readability by being able to refer to
groups of options and to omit either short or long options.

    - API-generated usage text tends to be poor not only because it lacks usage
      variants but also because the generated text exhaustively lists all
      options in all of their permutations (short and long).

    - Especially as the number of options grows, readability can be improved
      greatly by referring to sets of options by symbolic names rather than by
      enumerating every possibility (see `git help diff` for an illustration of
      this technique).

    - Similarly, readability can be enhanced by focusing the usage text on just
      the long-options (or just the short-options) and then providing a mapping
      between short and long options latter in the help text.

Allowing users to define arguments/options in ways that encourage modularity.

    - In argle a user defines/configures options and arguments as atomic
      units, separate from the issues of command-line grammar, usage variants,
      and options help text.

    - Each of those atomic units can be attached to one or more groups of
      related options.

    - Then those options or option-groups can be leveraged when defining the
      command-line grammar, when expressing the generated usage text, and when
      organizing the options text into sections.

Providing users with full access to the parser configuration, both via the API
and in the form of standard data structures.

Providing users more conventient mechanisms to reduce repetition in the
configuration of the parser.

--------
other-goals: Other goals
--------

Prioritize the simple use cases. Yes, add features and customization
capability. But do that without sacrificing simplicity for the easy cases.

Usage should be intuitive and declarative, especially for the simplest and most
common use cases. It should not depend on bizarre syntax or on complex
user-created data structures.

The parser's configuration should be expressible as a data structure. This is
important for testing, debugging, easy integration with other libraries.

For complex programs or special needs, users should have full control over
documentation. This includes both usage-text and help-text, as well as the
styling of error messages.

Easy system for validators to be combined flexibly.

Should easily support different help types: (a) brief usage/synopsis, (b) full
help or man-page, and (c) extras or examples. Regarding the latter, provide
utility functions to format/wrap any text blob in the same manner that Argle
would format official sections in the help text: p.format(BLOB) should return
text consistent with the look and behavior of other help text, based on Parser
defaults and configuration.

Include ability to merge options with user preferences. When a preference is
supplied, it should also cause a required option to become non-required.

Make it easy to test the option parser.

Error handling should be under the user's control, if they want it. This is a
serious flaw in some parsers (eg argparse). The library should support both
"automatic" mode (where the parser will eagerly print help or error message and
then exit) or non-automatic mode (where the parser will simply return an object
containing all information and allow the user to decide what to do. [Note that
argparse has partially addressed this in Python 3.9].

Should have a design that is friendly to customization. Allow users to
customize by writing simple functions or hooks rather than having to subclass.
Consider using the pluggy library so that users can implement simple function
hooks.

Start simple: begin with core behaviors; don't support more flexibility until a
basic working system is in place.

Where possible, rely on convention over configuration: sensible defaults to
allow the most common path to be followed with minimal setup.

Provide good support for --version. Show the application's name and version
number.

Provide helper functions for warn(), exit().

Support various configuration styles: per option configuration (argparse and
many other libraries do this); and thematic or bulk (make one type of setting
on multiple options at once).

Allow the user to have hidden options (eg for developers only).

Support file and dir types as arguments, with checks for existence or non-existence.

For file path arguments, support the ability to treat `-` as stdin or stdout.

Support an easy way to get bash tab-completion.

Support @somefile.txt: user supplies command-line args via a file.

Support parse_known_args().

Support abbreviated option names when there is no ambiguity.

Support some no-configuration argument parsing strategies: default (options are
flags), key-val (options take single args by default), greedy (options consume
as many params as possible).

Support conversion/validation.

Support dispatch mechanisms.

The parser's configuration is likely to be organized as a fairly deep tree
behind the scenes. But make it easy for the user to query that tree to obtain
nodes of interest for configuration and other purposes. Primarily this means
quickly getting Opt instances, but there could be other types of interest as
well.

Let users control the important aspects of the help text: section ordering;
section titles; layout style (eg, compact 2-column or man-page); capitalization
rules; widths; conventions for showing default values; etc.

--------
standard-cli-grammar: Standard command-line grammar
--------

Typical rules of command-line grammar, as commonly understood in Unix tradition:

    - Options start with a prefix:

        --long
        -s

    - Options can take zero or more ordered parameters.

    - Positional arguments are ordered among each other:

        P1 P2 P3 ...

    - Options can be ordered in any way:

        --x4 --x1 --x3 --x2 ...

    - Options can be freely interspersed among the ordered positional arguments.

        --x3 P1 --x1 --x4 P2 --x2 P3 ...

    - Short options can be bundled:

        -x -y -z
        -xyz

    - Options can take their own arguments (or parameters). As this behavior
      becomes more flexible it deviates more from the traditional Unix-based
      approach.

        -x X1
        -y Y1 Y2
        -z Z1 Z2 ...

--------
cli-grammar-vs-regex: Command-line grammar vs. regex
--------

Although Argle usage syntax borrows many concepts from regular expressions,
command-line grammar parsing is not readily amenable to handling via regex
parsing approaches.

Positionals are ordered among themselves, but options can appear in any order
(ignoring boundaries and anchors). That flexibility makes it not very intuitive
to convert a command-line grammar into a manageable regular expression. At
every stage, any of the options are possible. But then once an option appears,
it cannot appear again (ignoring repeatables). That means command-line parsing
is context-sensitive.

--------
subparsers-not-needed: Argle does not need the subparser concept
--------

The subparser concept is much less powerful and less intuitive than the key
concept of a command-line grammar, along with the related ideas of (1) usage
variants, (2) groups of options, and (3) flexible destination assignment.

The universe of command-line programs could be broken down into a sizable
majority and two small minorities:

    - A sizable majority:
        - Does not need subparsers
        - Has a simple grammar (in the classic Unix tradition).

    - A small minority:
        - Aligns conceptually with the subparser concept.
        - But a command-line grammar supports this use case even better.

    - A small minority:
        - Does not align well with the subparser concept.
        - But forced by the limitations of current argument parsing libraries
          to use subparsers as a last resort.

--------
opt-action-not-needed: Argle does not need the action concept
--------

Arguments can be configured in argparse with an 'action' parameter. The
parameter is a bit overloaded and misleading. It does control some actions (eg,
showing help text), but mostly it is used as a sometimes misnamed device for option type
and destination assignment.

    Action       | Option type       | Example         | Stored      | Notes
    ----------------------------------------------------------------------------------
    store_true   | Flag              | --frob          | True (N=1)  | .
    store_false  | Flag              | --frob          | False       | To override a True default
    count        | Repeatable flag   | -v -v           | N           | .
    store        | Single            | --foo F         | F           | .
    append       | Repeatable single | -x A -x B       | [A, B]      | Overwrite on repeat
    extend       | Repeatable multi  | -x A B -x C D E | [A B C D E] | .
    help         | Priority          | .               |             | .
    version      | "                 | .               | .           | .
    ----------------------------------------------------------------------------------
    store_const  | 1 flag            | --frob          | X           | Not necessary
    append_const | 1+ flag           | --frob --frob   | [X x]       | Not necessary

Notes:

    - To achieve argparse store_false:
        - The generalized case is a flag that stores some constant.
        - Default constant is True.
        - But user can define a convert function to store anything else.

    - Data storage to achieve argparse extend:
        - See parsed-data-structure

--------
explicit-var-input-syntax: Why explicit syntax is needed for variable inputs
--------

Imagine that the spec-syntax did not require explicit surrouding markers
(braces, angle brackets, or quote marks) for parameters, positionals, and
literal values. Every type of confusion would be possible.

    frob --type x y z   # Meaning of x, y, z unclear.

Some ways to address that problem:

    - Minimize syntax burden. Require that literals be quoted (because rarely
      needed) and positionals use angle brackets (because it is conventional).

    - Enforce consistency: require all 3 types of markers (and because braces
      for params are also conventional).

    - Be creative: require that literals be quoted and give users a mechanism
      to disambiguate when needed. Probably a bad idea: these issues can be
      tricky to think through. Also, for non-standard grammars, a small bit of
      extra typing seems easy compared to having to reason about subleties.

--------
variable-input-spec: Spec for variable input
--------

The initial spec-syntax handled variable input like this:

    - Approach #1: incorrect.

        <dest>       | Positional
        --dest <sym> | Option with parameter

Then I switched to the following:

    - A sym represents the ultimate help-text.
    - Thus, names in the spec are better understood as syms, not dests.
    - A positional defaults to having the same name for its sym and dest.

    - Approach #2: also incorrect.

        <sym>        | Positional
        --dest <sym> | Option with parameter

But now I think the spec is symbolic names all the way down:

    - An option (formerly modeled as --dest) is just a thing with a symbolic
      name (--sym). And since everything is a syn/name, just use natural
      language (--name).

    - Approach #3:

        - Abstract (unlikely to ever be documented this way).

            <name>        | Positional
            --name <name> | Option with parameter

        - More intuitive description of the policy.

            <foo>        | Positional, with Opt.name=foo
            --bar <fubb> | Option, with Opt.name=bar and having Parameter.name=fubb

    - How this approach works with all entities having names:

        - Symbolic names in help-text:
            - Opt
            - Parameter
            - Group

        - Symbolic name in the spec/API:
            - Section
            - Variant

For a while, I considered a more elaborate var-input-spec that allowed the user
to configure name and dest independently.

    - But it seems not worth it.

        # Too complex.
        <dest.name>           | Positional
        --name <subdest.name> | Option with parameter

    - The most common use is with plural nargs:
        - Plural dest (eg paths).
        - Singular name (path).

    - But this is more naturally configured via the API.

    - In addition, the subdest concept is unneeded:
        - The purpose is to package up the positional/parameter values
          up into a different, object-like data structure.
        - The appropriate solution here is a user-provided convert function.

--------
opts-revised-OO-plan: Revised OO plan for Opts and child elements
--------

In prior planing, Opt and Arg were multi-purpose:

    - A kind attribute would distinguish positional vs option.

    - The thought was that the degree of overlap was large and that a little
      bit of conditional logic in some methods was better than a more complex
      OO model.

    - But I have decided to switch to a more structured OO approach.

New OO model:

    Opt subclasses | Arg subclasses
    ---------------------------------
    Positional     | Argument
    Option         | Parameter
    Literal        | .

    - What is new:
        - Explicit subclasses.
        - Name change: OptArg => Arg.

Reasons for using explicit subclasses:

    - Different behaviors and policies:

        - Ordering rules:
            - Positionals are ordered among themselves.
            - Options are not.
            - Literals impose left-right dividers.

        - Different policies regarding name and dest:
            - Argument: anonymous (and maybe no help text).
            - Literal: by default, dest=None and data discarded.

        - Options have more features:
            - Aliases, negaters, and priority.

        - Different support for quantifiers:
            - Argument: no ntimes (lives on the Positional).
            - Literals: no quantifiers.

        - A simpler object-graph is always good, but those differences feel
          significant enough to warrant a more robust OO approach.

    - Documentation and project notes can be simpler and more direct:
        - Useful to have separate terms.

    - Querying is a bit simpler:

        - At least for users intent on using no magic values in their code.

        p.query(PATH, kind = Positional)
        p.query(PATH, kind = OptKinds.positional)

Reasons for the name change: OptArg to Arg:
    - Simpler.
    - Parallels Opt: both base class have compact names.
    - Aligns well with nargs.

Why I decided against Option.nparams:
    - The paralleism of Option.nparams is somewhat appealing.
    - But nargs is more familiar (argparse, Click).
    - It aligns with Arg (just noted above).
    - Option.nparams too specific: nargs means "N of Parameters and Groups".

Why Literals cannot have a name:
    - A name would be used in the usage-text.
    - Which defeats the purpose of a Literal.

Why Literals do not support quantifiers and dests:

    - Difficult to imagine plausible use cases:

        `fast`... <x> <y>
        [`down`] <x> <y>

    - User has a good (and better) workaround:
        - Define a Positional with one choice.
        - The choice will appear in the usage text (as desired).
        - Positionals support quantifiers.
        - Data would be stored in a dest.
        - And the Positional could be anchored if the user cases about the
          divider-aspect of a Literal.

        <speed=fast>... <x> <y>
        [<direction=down>] <x> <y>

    - The existence of a better workaround implies that a Literal also has no
      need for a dest.

Literals as a grammatical dividers:

    - A Literal creates a strict boundary between stuff to its left/right.
    - A Positional is similar, but less strict:
        - A divider only among other positionals.

    - Implement divider-behavior using existing concepts:

        - Do it as a post-processing step.
        - Traverse Grammar elements.
        - If Literal:
            - Get innermost enclosure (Alternative, Group, Variant).
            - If Literal can be anchored directly, just do it.
            - Otherwise, divide the enclosure's elements into left-right.
            - Put the sides into anonymous Groups.
            - Anchor Literal to end of the left Group.

--------
groups-can-be-parameters: Options can have Groups as parameters
--------

The idea that options can have groups as parameters is a bit surpising:

    --point <x> (<y> <z>)...

    (1) A flag, a positional, and then a Group.
    (2) Or an option with two parameters: Parameter then Group.

    - The first intpretation is tempting, but incorrect.

Rationale based on parsing philosophy:

    - That ambiguity noted above is just a fancy version of a fundamental
      ambiguity already worked out:

        - This is an option with two parameters:

            --point <x> <y>

        - A flag and two positionals looks like this:

            (--point) <x> <y>

        - Or like this:

            <x> <y> --point

    - Why? The usual greedy parsing logic.

        - Without a greedy policy, many ambiguities/complications arise.
        - Groups as parameters is just a logical extension of the core idea.

    - One could propose special policy workarounds:

        - Groups cannot be parameters.
        - But then an optional parameter becomes awkward:

            --help [<topic>]

        - One could add more policy: bracketed, degenerate group with one
          paramater can be a paramater.
        - And that starts to feel finicky.

Rationale based on core features:

    - Parameters and positionals are similar in most respects.
    - Positionals can reside in groups with rich quantifiers.
    - Parameters should do the same.

    - These plausible and similar use cases:

        scores=(<lo> <hi>)...
        --scores (<lo> <hi>)...

--------
parser-config-api: Parser.config() API
--------

The config() method is the main API to configure Opts:

    p = Parser(SPEC)
    p.config(*paths, **kws)

    - The call is a shortcut for:

        p.query(*paths).config(**kws)

    - For Opts returned by query(), sets their attributes based on kws.

    - For query() details, see grammar-querying-api

Notation used here:
    - Opt: any grammar element that matches query.
    - PATH: query-path.
    - Opt attributes: foo, bar, etc.
    - VAL: values assigned to Opt attributes (shown as ints).

Two general styles of config() calls:

    - Distinct: for a given attribute, Opts get distinct configuration.
        - No *paths are supplied.
        - Instead each attribute has a dict[PATH => VAL].

        p.config(
            foo = {'PATH_1': 111, 'PATH_2': 222},
            bar = {'PATH_3': 77, 'PATH_4': 88},
        )

    - Consistent: for a given attribute, Opts get the same configuration.
        - One or more PATHS are supplied.
        - Each attribute has a simple VAL.

        p.config_B(
            'PATH_1', 'PATH_2',
            fubb = 3,
            blort = 4
        )

--------
opt-and-arg-configuration: Configuration of Opt and Arg
--------

Opt child elements: Positionals vs Options:

    - Options:

        - In vast majority of cases, all children will be Parameters.
        - But elems can also be Groups (due to greedy parsing policy):

            --foo (<x>{2} <y>){3}
            --point <x> (<y> <z>)...

    - Positionals:

        - Child elems must be Argument.
        - Under spec-parsing policies you cannot create a Positional having
          Groups as children.

Quantifiers and configuration independence among Args:

    - Examples:

        (--point <x> <y> <z>...){1,4}

        Option(name=point, nargs=(3,None), ntimes=(1,4))
            Parameter(name=x, ntimes=1)
            Parameter(name=y, ntimes=1)
            Parameter(name=z, ntimes=(1,None))

        <val>{2}{3}

        Positional(name=val, nargs=2, ntimes=3)
            Argument(name=None, ntimes=1)
            Argument(name=None, ntimes=1)

    - Key points:

        - N of Args is based on nargs.

        - Each Arg represents 1 independently configurable entity.
        - Repetition across ntimes does not create independent units.

        - Quantifiers available:
            - Opt: nargs and ntimes.
            - Arg: ntimes.
                - Represents one configurable entity.
                - Which aligns with nargs restricted to 1.

Names of Args:

    - Options have flexibility in naming:

        - The Option has a name.
        - The Parameter names can take various forms.

        --point <x> <y>  # Distinct names.
        --point <p> <p>  # Shared name.
        --point <p>{2}   # Ditto.
        --point <> <>    # Anonymous.

    - Positionals are much more restricted:

        - Two approaches were considered:
            - Shared name (copied from parent Positional).
            - Anonymous.

            - Argle policy: anonymous.

        - That policy addresses a querying problem with shared-names:

            - Queries by name would return Positional and children.
            - Most common use case is to query just for the Positional.
            - Query-via-index can address the less common use cases.

Assignment of Arg attributes via the parent-Opt:

    - An example for the discussion:

        p = Parser('<x>{2} [<y>] [-z <a> <b>]')

    - Configuration of Opts and Args:

        - The most common and intuitive use cases:
            - User wants child Args to have identical configuration.
            - They want to apply that configuration via the Opt.name.

            # Should adhere to the DWIM policy.
            p.config('x', default = 888, convert = int)
            p.config('y', default = 0.0, convert = float)

        - Sometimes users want separate configurations for the children.

    - The complication:

        - Strict interpretion of query(PATH) would be bad:

            - A query by Opt.name will get the Opt, not the Args.
            - Forcing users query explicitly would be annoying.

            # Tedious.
            query('z.a', 'z.b')
            query('x.0', 'x.1')

        - Opt and Arg share some attribute names.

    - The policy:

        - If the query() PATH gets an Opt.
        - Apply each setting, based on its kwarg, to the appropriate object(s).

        - If kwarg is shared by Opt/Arg, apply setting to the Opt.
            - The shared attributes (spec, name, text, ntimes) are not natural
              fits for configuration via query().
            - Users who need to can use explicit paths.

            p.config('z', name = 'bar')   # Applies to parent.
            p.config('z.a', name = 'z1')  # Applies to the child.

        - To configure children differently, use a list.

            p.config('z', default = 9)        # Same defaults for <a> and <b>.
            p.config('z', default = [77, 88]) # Different.

--------
help-text-formatting-and-api: Help text formatting and API
--------

Top-level API to configure help-text:

    p = Parser(SPEC)
    p.config_help_text(**kws)

Help-text configuration parameters:

    p.config_help_text(
        options_summary            = '<options>',
        opt_desc_style             = 'default',
        opt_listing_heading        = 'unified',
        opt_listing_heading_indent = -4,
        alias_listing              = 'compact',
        min_width                  = 40
        max_width                  = 100
    )

    - options_summary: whether/how to summarize options in usage:

        - If a PLACEHOLDER is set (the default), it will be used to summarize
          the options in the command-line usage.

            blort [<options>] <path>...

        - The user can specify a different PLACEHOLDER.
        - Or set it to empty str (or any false value) to disable.
        - If that is done, options are listed explicitly in usage.

    - opt_desc_style: layout style for opt-descs:

        - default (or None):
            - The typical two-column style.
            - Examples: argparse.

            <rgx>                  Python regular expression
            <path>                 Path(s) to input
            --ignore-case, -i      Ignore case

        - manpage:
            - Each opt-spec on its own line.
            - Then an indented paragraph of help-text.

            --output <file>
                Output to a specific file instead of stdout. Blah blah
                blah blah blah.

    - opt_listing_heading: default heading/organization for opt-listings:
        - unified: "Arguments".
        - by_kind: "Positionals" and "Options".
        - minimal: no heading.

    - opt_listing_heading_indent: indentation of heading:
        - Indentation in N of spaces.
        - Expressed relative to indentation of the opt-listing in the spec.

    - alias_listing: styles for documenting aliases in opt-listings:
        - explicit: classic style (argparse).
        - compact: same, but drop parameters on the aliases.
        - column: like compact, but in a column.
        - separate: like column, but the aliases under a separate heading.

        - Mockups:

            # Explicit.

            --ignore-case, -i      Ignore case
            --group <n>, -g <n>    Emit just capture group N [0 for all]
            --delim <s>, -d <s>    Delimeter for capture groups [tab]

            # Compact.

            --ignore-case, -i      Ignore case
            --group <n>, -g        Emit just capture group N [0 for all]
            --delim <s>, -d        Delimeter for capture groups [tab]

            # Column.

            --ignore-case      -i  Ignore case
            --group <n>        -g  Emit just capture group N [0 for all]
            --delim <s>        -d  Delimeter for capture groups [tab]

            # Separate.

            --ignore-case          Ignore case
            --group <n>            Emit just capture group N [0 for all]
            --delim <s>            Delimeter for capture groups [tab]

            Aliases:
              --ignore-case    -i
              --group          -g
              --delim          -d

    - min_width and max_width: of text wrapping:
        - Under typical conditions, text is wrapped to terminal width.
        - But there are lower and upper limits.

Processing of user-supplied block-quotes:

    - Break into paragraphs (but preserve info about N of blank lines
      between paragraphs).

    - Rewrap to the desired width (probably using textwrap module).

    - During wrapping, preserve the paragraphs original level of indentation
      (based on the first line).

    - Provide an easy syntax for users to suppress line wrapping within the
      text (eg something borrowed from markdown)

Why all literal text must be block-quoted:

    - Because it would be difficult to distinguish opt-spec continuation lines
      from lines of regular text in a section.

    - This keeps parsing relative sane at a modest cost in usage.

--------
spec-parsing-general-approach: Spec parsing: general approach
--------

Phase 1: input normalization:

    - Accept text and/or lines of text.
    - Join into a block of text.

Phase 2: lexing:

    - Remember that the lexer analyzes character by character to emit
      a flat streem of the meaningful atomic units of the language.

    - It does not engage in validation logic to assess whether the arrangement
      of those units is syntactically valid.

    - Nor does it try to assemble those character-based atoms into fully
      meaningful entitities, other than in cases where they must be assembled
      to avoid ambiguity with similar tokens.

Phase 3: parsing:

    - A parser's job is to eat a stream of tokens, organizing them into
      meaningful and valid units, and emitting those units to the caller.

    - Handlers should be substantive from the perspective of the language, not
      low level.

    - Because the tokens and handlers differs somewhat between the grammar
      section and other sections, the parsing needs to be stateful -- advancing
      to the section state at the first section-tile line after the grammar
      section.

Phase 4: assembly:

    - The parser phase is the most complex, so don't overburden it with the
      duty of creating the ultimate grammar elements.

    - Instead, keep the parser simpler by having it emit simple AST-style
      objects.

    - The last phase converts the AST to true grammar elements.

--------
arg-parsing-algo: Parsing algorithm
--------

Notation and terminology:

    - Purely notational concepts:

        Pos:         A positional Opt.
        MGroup:      A Group having mutex=True.
        Alternative: A Variant or MGroup.
        OPT:         When current arg looks like an Opt.
        POS:         When current arg looks like a Pos.

    - Parsing terms:

        - Alternatives: the Variants and MGroups determine how many
          alternatives we will try.

        - Interpretations: within an alternative, there can be multiple valid
          interpretations of the arguments -- specifically how they are
          allocated to Opts either as positionals or params.

        - Backtracking terms:

            - Current interpretation or parsing route: the interpretation you
              are currently on, based on a successful parse of the current arg.

            - Foregone interpretation: the interpretation that you could have
              selected, but did not -- so you push it to the stack before proceeding
              with the current interpretation.

Some key insights related to backtracking:

    - Parsing decisions that might require backtracking come from positional
      arguments or parameters, not options. Options, if present, are
      non-ambiguous: either they are known and allowed, or not.

    - Backtracking is needed when your current parsing route ends up attaching
      a param to an Opt or an argument to a Pos but then that route ultimately
      fails (on a later argument). You need to backtrack to check any foregone
      alternative interpretations of the input arguments.

    - Alternative interpretations are possible only for Opt with non-static
      nargs and/or non-static ntimes.

    - So pushing to the stack needs to happen when your parsing decision for
      the current argument creates a foregone alternative.

    - This occurs only for successful parsing of the current argument; never
      for errors.

    - Variants and MGroups also don't require a backtracking mechanism.

        - Rather, you want to process all of the alternatives in order, based
          on the Grammar. Each alternative either succeeds or fails. And you
          stop on the first success.

        - The best time to load the stack with these alternatives is before the
          while-stack loop begins. This will ensure that each alternative will
          be tried in order. Because we are using a stack, backtracking within
          any specific alternative (due to non-static nargs) will finish before
          the algorithm advances to a fresh alternative.

        - If you were to try to push foregone interpretations to the stack when
          an alternative fails, you interfere with the correct ordering of the
          alternatives. Perhaps even worse, it's not easy to know within the
          while-stack loop when an alternative has totally failed. Each
          iteration of the loop can be either starting a fresh alternative or
          exploring one of the different interpretations possible within the
          alternative.

A backtracking example:

    Grammar:
        Opt('-f', nargs = (1,3))
        Opt('x', nargs = (3,4))

    Input:
        -f V1 V2 V3 V4 V5

    Parsing logic:

        -f : Valid: attach it to Opt(-f).

        V1 : Attach to Opt(-f)

        V2 : Because Opt(-f) is greedy by default, attach. But
             this attachment is not required due to non-static
             nargs. Before pushing the new State where V2
             is attached to Opt(-f), we should push the foregone
             interpretation -- namely, where we restrict Opt(-f)
             to nargs of (1,1).

        V3 : Same logic: attach and push foregone interpretation.

        V4 : Attach to Opt(x).

        V5 : Same.

        -  : Now we're out of arguments and have not
             satisfied Opt(x). So this interpretation fails.
             The next State in the stack will restrict
             Opt(-f) to nargs of (2,2), which will succeed.

    Logic if Opt(-f) had been non-greedy.

        V2 : Don't attach to Opt(-f). Now the foregone interpretation
             is for Opt(-f) with nargs of (2,3). Push that
             to the stack.

State:

    - Data object to hold parsing state as the various interpretations from the
      grammar are being tried during the while-stack loop.

    - Attributes:

        ai: index of args.

        next_pos: next available Pos [or None].

        nps: nargs remaining for the active Opt [or None].
            ** Rename attribute to nas

        avail: map of available Opt to remaining ntimes [0 for exhausted].

        target: Target instance holding parsed data accumulated so far.

        err: error that terminated the current alterantive [or None].

        variant: name/id/index for the current variant; relevant for
        error selection/reporting, not parsing directly.

ArgResult:

    Data object to represent info need to capture the result-so-far
    for the parsing the current arg. Some likely attributes:

        err: data object holding error info
        opt: matched Opt
        val: converted value

    Notation used here:

        ArgResult(ERR: ...) | Current arg failed.
        ArgResult(OPT)      | Current arg matched OPT.
        ArgResult(PARAM)    | Current arg matched PARAM.
        ArgResult(POS)      | Current arg matched POS.
        ArgResult(UNKNOWN)  | For forge-ahead-mode or parse-known-mode.

How to handle Groups with non-static ntimes:

    - A Group can be optional overall (optional is one type of non-static), but
      have required elements if the Group is triggered by the presence of any
      of its elements. For example, if either -x or -y are present, both are
      needed.

        [ -x -y [-i] ]

    - When to handle such matters:

        - During parse. For example, when we see -x, then we would
          immediately adjust ntimes for -y.

        - After a successfull ArgResult. Before checking Opts for sufficient
          nargs and ntimes, we would first adjust those expectations based on
          any Groups that were activated by the presence of the Opts.

    - The latter, for two reasons:

        - Groups can alter quantifier expections. It makes sense to do all of
          that quantifier checking together.

        - More fundamentally, an optional Group can contain positionals and
          params. Like in the rest of the grammar, greedy is the default. That
          means positionals within optional Groups should be attached eagerly.
          It could get very messy trying to support some special logic just for
          optional Groups. The user has multiple ways to configure the grammar
          if the default greediness isn't desired.

Algorithm: setup:

    Stuff from the end-user or user:

        args = [...]

        P = Parser(...)
        G = P.grammar

    Initialize the stack that drives the algorithm. For every allowed combo of
    Variant and MGroup, add a State instance to represent the initial
    conditions of each alternative.

        # The stack of States.
        stack = [S1, S2, ...]
        stack = list(reversed(stack))

        # Every State examined and whether the entire parse is complete.
        history = []
        success = False

        # Parser-wide inventory of all known OPT.
        known_opts = G.get_all_options()

Algorithm: parsing loop:

    while stack and not success:

        # Prep.

        S = stack.pop()
        arg = args[S.ai]
        T = P.get_arg_type(arg)
        ares = ArgResult()

        # Check arg type.

        if T is OPT:

            # Handle aliases and fuzzy match.
            if arg not in S.avail:
                arg = P.fuzzy_match(arg)

            if arg not in known_opts:
                ares = ArgResult(ERR: globally unknown OPT)
            elif arg not in S.avail:
                ares = ArgResult(ERR: inapplicable OPT)
            elif S.nps is not None:
                ares = ArgResult(ERR: expected param but got OPT)
            elif S.avail[arg] == 0:
                ares = ArgResult(ERR: OPT occurred too many times)
            else:
                ares = ArgResult(OPT)

        else:
            if S.nps[arg]:
                ares = ArgResult(PARAM)
            elif S.next_pos is not None:
                ares = ArgResult(POS)
            else:
                ares = ArgResult(ERR: too many POS arguments)

        # Conversion and validation for PARAM and POS.

        if not ares.ERR and not ares.OPT:
            null = object()
            val = null
            ok = null
            err = None
            try:
                val = ares.opt.convert(arg)
                ok = ares.opt.validate(val)
            except (...) as e:
                ares.err = captured info about the error

            if ok is not True and (forge-ahead-mode or parse-known-mode):
                # Treat as success.
                ares.best_effort = True
                ares.val = arg
            elif val is null:
                ares = ArgResult(ERR: conversion raised an error)
            elif ok is null:
                ares = ArgResult(ERR: validation raised an error)
            elif ok is False:
                ares = ArgResult(ERR: validation returned False)
            else:
                # Success.
                ares.val = val

        # Handle less restrictive parsing modes.

        if ares.ERR and (forge-ahead-mode or parse-known-mode):
            ares = ArgResult(UNKNOWN)

        # Check for overall success if args exhausted.

        if ares.ERR is None and S.ai + 1 == len(args):

            - First check whether any Groups have been activated by the present
              Opts. If so, adjust expected ntimes accordingly.

            - Then check that all Opts have sufficient nargs, ntimes.

            if OK:
                success = True
            else:
                ares = ArgResult(ERR: insufficient ntimes/nargs)

        # Store history, push foregone, check overall success.

        if ares.ERR:
            # On error, just store the history.
            S.target.add(ares)
            history.append(S)

        else:

            # Check for foregone interpretation.
            # Not yet sure if we should perform these steps for ArgResult(UNKNOWN).
            if not success and (ares.PARAM or ares.POS):
                If either of these apply to the matched Opt:
                    - Non-static nargs.
                    - Non-static ntimes.
                Then:
                    S2 = new State to represent the foregone parsing route
                    stack.push(S2)

            # Store history.
            S.target.add(ares)
            history.append(S)

            # Create next parsing State.
            S1 = new State based on current parsing route
            stack.push(S1)

Algorithm: wrap up:

    if success:
        return history[-1].target

    else:
        - Examine history to find most relevant error.
        - Return or raise, depending on Parser configuration.

Post-parsing logic:

    target = self.do_parse(...)

    Load the data from target into a Result. Details will vary based on Parser
    configuration and parsing-mode.

--------
alternative-parsing-algo: Alternative parsing algorithm won't work after all
--------

The algorithm:

    - When parse() is called, there will be N command line arguments.
      Command-line use cases never have large N.

    - Using the parser configuration, assemble data on the aspects of the
      grammar that are not static. The most common non-static configurations:
      varying nargs or ntimes; variants; and alternatives.

    - For grammar elements that have no inherent boundaries (eg, an option
      taking 1+ params), interpret them in as bounded by using N as the upper
      limit.

    - Use all of that information to generate all static grammars that satisfy
      the actual grammar.

    - Check each static grammar against the command line arguments.

    - A successful parse finds exactly one successful static grammar.

What causes a grammar to generate multiple possibilities?

    .              | Where expressed | Note
    -----------------------------------------------------
    Varying nargs  | Opt             | .
    Varying ntimes | Opt or Phrase   | Includes required.
    Alternatives   | Phrase          | Includes variants.
    Aliases        | Opt             | .

Benefits of the algorithm:

    - This code seems easy to write:

        - The generation of static grammars seems like a manageable
          situation involving itertools.

        - Parsing a static grammar very simple: no backtracking required.

    - It provides a run-time guard for users against ambiguous grammars.

Three concerns:

    - The approach seems non-standard. A classic stack algorithm seems to suit
      the situation. And that code might not be any harder to write -- perhaps
      just a bit less familiar. Why reinvent the wheel? Make sure there's a
      good reason.

    - Modern operating systems and shells have very large limits on the max
      size of command lines and N of arguments. Why build a good argument
      parsing tool that would fail at moderate values for N -- especially
      when a linear algorithm is known?

    - There won't necessarily be only one successful parse of the static
      grammars, as noted in the discussion of ambiguous grammars. By using a
      greedy assignment policy the parser can ignore that matter. But regular
      expressions have a greedy concept precisely because without it there can
      be more than one successful parse of an input. [On further reflection,
      this point argues against expecting only one successful static grammar.
      But if you try the static grammars in the correct order, based on greedy
      policies in place, you can stop at the first success -- as regex does.]

--------
ambiguous-grammars: Ambiguous grammars are not an issue
--------

From a very strict perspective, only one positional can have a non-static nargs
or ntimes, because there isn't exactly one valid way to attach the values to
the destination attributes. A similar problem occurs when an option or
positional has non-static nargs. Two examples:

    <xray>...    <y>...
    --xray {}... <y>...

But that's not a problem, because Argle can do what regular expression
engines do: greedy assignment by default, non-greedy by configuration.

--------
opt-choices-vs-choice: Opt.choices vs Opt.choice
--------

Early planning made a distinction:

    - Regular Opt: with choices:
    - Assumed to be purely a validation concern.

        <step=run|walk|fly>

    - Arg-variant: Opt with 1 choice.
    - A grammatical concern.

        <step=eat>

But that dichotomy is flawed:

    - Grammar via Opts with 1 choice:

        other! : [--foo] [--bar]

        <step=start> other!
        <step=stop> other!

    - Same grammar via Opt with 1+ choices:

        <step=start|stop> other!

    - Choices are both:
        - A mechanism to check for valid input.
        - A compact way to define alternatives.

--------
opt-independence: Opt independence, duplicate names/dest, and opt-spec scope
--------

How should Argle handle repetitions of a name/dest within a spec?

    - The spec-syntax is very general/flexible.
    - Nothing in the syntax prevents a user from using the same name or dest
      across positionals, options, parameters, or even groups.

    - Notation:
        - Discussion will use "name" to represent name or dest.

Examples: some theoretical edge cases:

    - These are not meant to be realistic.
    - Not easy to envision a good use case for many of them.
    - But they do sketch a broad range of possibilities.
    - They do not include name repetitions among group names.

    - Contiguous repetition;

        <x> <x> [<x>]               # Contiguous.
        -x [-x]

        -x -y -x                    # Noncontiguous.
        <x> <yy> <x>

    - Reuse across variants:

        foo : <x> [-y]              # Same configuration.
        bar : -z -y <x>

        foo : <x> [-y]              # Different configuration.
        bar : -z -y <x>...

        foo : <x> [-y]              # Different Opt kinds.
        bar : -z -y [-x]

    - Reuse across alternatives:

        (-x -y | -a -x -z | -q)     # Same configuration.

        (<x=A|B> | <x>{3})          # Different configuration.

        (-x | <x> <x>)              # Different Opt kinds.

    - Reuse within an alternative:

        <x> (<x>{2})...             # Different configuration.
        -x <x> <x>                  # Different kinds.

Example: a small and plausible sub-command program:

    - The --bar option needs different:
        - N of parameters.
        - Help-texts.
        - Maybe other stuff (convert, validate, etc).
    - The -x option needs different:
        - Help-texts.

    - The spec:

        <cmd=grep> [-i] [--bar <b>] [-x]
        <cmd=blort> [--bar <b1> <b2>] [-x]

        Searching ::

        [-i] : Ignore case
        [-b --bar <b>] : Bar parameter
        [-x] : Extended mode

        Blorting ::

        [--bar <b1> [<b2>]] : Bar parameter or range (inclusive)
        [-x] : Extended mode, with regex

    - How would Argle know to connect the opt-specs to the correct Opts in
      the usage grammar?

        - Natural home for some likely configuration differences is the spec:
            - Help text.
            - Aliases.
            - The grammar within the Opt's arguments (as shown above).

            - So forcing users to rely on the API entirely for ambiguous
              situations seems inferior.

        - Argle could make the connections via a default policy:
            - It could infer the --bar connections correctly,
              based on parameter differences.
            - Ditto if the Opts sharing a name were of different kinds.
            - But the -x flags differ only in help-text.
            - Argle could use a fallback: connect Opts in order.

            - But forcing user to check/fix the connections via API seems awkward.

Examples: plausible separator-based grammars:

    - EX_NAB
    - EX_NECK_DIAG

    - These illustrate why Opt independence within the same variant is
      sometimes needed:

        - I considered disallowing name reuse within variants.

        - But a separator-based grammar needs a single main variant:
            - Where the subcommands can be used in sequence.
            - The sequence can even include repetitions of the same subcommand.

        - Subcommands are likely to need Opts having the same name:
            - Often with same configuration across Opts sharing a name.
            - But not always.
            - Especially in help-text and aliases.

Example: arg-variants:

    - This type of example was overlooked in prior planning.
    - Similar example: Argle naval-fate.

    <action=pitch> <action=balk|stop> [--foo]
    <action=catch> [--bar] [--foo]

    - Two key points:

        - Unifying the <action> Opts is compelling:
            - So Parser knows choices and can provide helpful error messages.

        - An arg-variant can be repeated within one variant.
            - When that occurs the Opt.choices are trickier.
                - pitch|catch
                - balk|stop

Key issues:

    - Validity of name repetition:

        - Should Argle disallow repetitions? If so, how widely:

        - Across entire spec.
        - Within a variant.
        - Within a the innnermost enclosing-entity:
            - Alternative
            - Group
            - Variant.

    - Opt unification/consolidation:

        - Should each Opt implied by spec be distinct?
        - Strict Opt independence.

        - Should Argle consolidate Opts having the same name/config?
        - Limited Opt independence.

Policy decisions:

    - Opt independence:
        - This is the governing approach.
        - Create a distinct Opt for each entity implied by the spec.

    - But with an important exception:
        - Opts having choice(s).
        - These will be unified under the shared name.

    - Connection opt-spec configurations to Opts from the variants:

        - An opt-spec will be connected to all Opts in the grammar having
          compatible configurations.

        - Because Opts declared in the grammar can be opt-mentions, the
          compatibility requirements are basic:

            - The intuitive parts:
                - Same name.
                - Same kind: positional or option.
                - Agreement with the opt-scope (if any).

            - The deeper principle:
                - The configuration from the opt-spec must be additive.
                - It cannot replace or contradict any configuration information
                  from the opt declared in the grammar.

            - Any opts from the grammar that "match" the configuration from an
              opt-spec (in the ways just described) will receive the additional
              configuration from the opt-spec.

            - If no opts match, Argle will raise.

    - Spec-scopes to disambiguate, via this syntax:

        PARENT >> CHILD

        Where PARENT is a path, as used in Parser.query().

        And CHILD can be:
            - opt-spec
            - section-title (governs all opt-specs in the section)

Discussion of the policy across various domains:

    - Why consolidation of contiguous repetitions is a bad idea:

        - Argle could consolidate contiguous repetitions.
        - Provided that they had the same configuration.

        - But consolidation seems tricky to implement:
            - You do not know if the configurations for a repeated name
              are truly the same until the very end.
            - After full spec is parsed.
            - After all API configuration is done.

        - Consolidation also loses information:
            - How the user wants the usage text to look.

    - Why name uniqueness is not needed in the Grammar:

        - A Grammar is just a list[Group or Opt].
        - The name and dest are not quique IDs.
        - So no problems are caused by repetition.

    - Why Opt independence works fine with API configuration:

        - A policy of Opt independence might create Opt clones:
            - Opts with same name.
            - With same configuration.
            - That the user intends to be the same entity.

        - But that is not a problem:
            - The same API call can configure one Opt or a bunch of clone Opts.
            - The user does not care whether the underlying Opts are
              independent or consolidated.

        - Yes, the user can define a weird spec that might make querying
          for individual Opts inconvenient.
            - But that is readily fixed via a more sensible configuration.
            - Worst case, user can query via indexes.
            - Or winnow down via subqueries.

    - Why name uniqueness is not needed by argument parsing:

        - Parsing involves putting arguments in viable slots.
        - No deep problems are caused by slots having same name.
        - Or by slots accepting the same kinds of things.

    - Arg-variants and error messages:

        - Opts with choices will be unified if they share a name.
        - For some edge-case usages, Opt.choices will be too broad.

        - That is an acceptable cost in those situations:
            - Yes, the error message will list too many choices.
            - But the alternative is worse:
                - Do not unify the Opts.
                - Such error messages would list only one choice!
            - Real solution a more sensible spec from the user.

        - Better to keep arg-parsing simpler.
            - At the moment of invalid input, get the valid choices from the
              unified Opt.
            - Implemented a correct listing of choices would require also
              storing a subset of choices in the Arg.
            - Which might be too awkward.

    - Consolidation necessarily occurs during Result creation:

        - This is where unification by dest occurs.
        - Consider Opts with different types:

            -x <x>{2}

        - This causes no technical problem:
            - Just wrap the data in an outer list.
            - One element per dest repetition.

            Result.x = [bool, [x1, x2]]

        - That data is narrowly correct (and awkward).
        - User can configure more sensibly if they do not like it.

Querying in the face of repeated names:

    - Start with some examples.

    - Example: simpler and realistic:
        - Variant and opt with same name: foo > foo.
        - How does the user get only the top element?

    - Example: pathalogical edge-case:
        - Several nests elements with same name: x > x > x > x.

    - I considered augmenting the PATH syntax for query().
        - But decided against that.
        - User can fallback to indexes where needed.
        - In simple/realistic situations, that will not be a burden.

    - Rejected alternatives:

        - Trailing period to mean "don't go deeper".
            - Insufficient by itself.
            - query('foo.') would still get both elements.
            - Why: because the path is not anchored to the start.

        - Also add syntax to anchor to the start.
            - query('.foo.') would get only the 1st element.
            - But consider: query('.x.x.').
                - Would it get only 2nd element?
                - No: would get 2nd, 3rd, 4th.
            - Problem: middle dot does not require direct parent-child.

        - Make paths like CSS:
            - Support both kinds of parentage:
                - Single-dot: parent-child.
                - Double-dot: any-descendant.
            - Problem: insufficient.
                - query('x.x.x'): gets 3rd and 4th
                - You also need ability to achor to the start.

        - Double-dot plus start-anchor:
            - Would work.
            - query('^x.x.x'): gets only 3rd.
            - Syntax reasonably intuitive.
            - But the solution addresses only strange use cases.
            - Defer this until known and compelling need arises.

Background for the opt-scope syntax:

    - It borrows from CSS syntax for parent-child.

        PARENT > CHILD

    - Why double the marker?

        - Argle parent-child differs from CSS:

            - CSS: marker means direct parent-child.
            - Argle: marker means any hierarchical nesting:
                - parent to child
                - any grandparent to child

        - The single > marker looks too much like a var-input:

            <foo>  # A var-input.
            foo >  # Opt-spec scope or a var-input typo?
            foo>   # Ditto, but even more likely to confuse.

    - I discussed the syntax with ChatGPT and got an impressive answer.

        https://chatgpt.com/share/67e1c05f-f654-8003-9c07-c556cea6c368

--------
parsed-data-structure: Parsed data structure
--------

The meaning of nargs and ntimes:

    nargs  : N arguments (for positionals) or parameters (for options).
    ntimes : Governs only optionality and repetition via {m,n} or its shortcuts.

    Options:                    #  nargs   ntimes

        -y                      #  0        (1,1)
        [-y]                    #  0        (0,1)
        [-y {} {}]              #  2        (0,1)
        -y {} [{}]              #  (1,2)    (1,1)
        -y {}{3}                #  3        (1,1)

    Positionals:                #  nargs    ntimes

        <x>                     #  1        (1,1)
        [<x>]                   #  1        (0,1)
        <x>{4}{0,2}             #  4        (0,2)

Internally, all data assigned to destinations will be stored in a fully
explicit manner. Assume a list of lists, where:

    Opt attribute | Determines length of
    ------------------------------------
    nargs         | inner list
    ntimes        | outer list

    - Singular nargs and ntimes:

        a1     # Either value or bool (latter if nargs is zero).

    - Plural nargs:

        [a1, a2, ...]

    - With plural ntimes:

        <z>{2}{3}

        [[a1, a2], ..., ...]

    - With a layer of nested plural ntimes (and no Group.dest):

        (
            --foo <> <>
            <z>{2}{3}
        ){4}

        foo: nargs   2, ntimes 1 x 4
        z  : nargs   2, ntimes 3 x 4

        foo = [
            [a1, a2],                # One group of data.
            ...,
            ...,
            ...,
        ]

        z = [
            [[a1, a2], ..., ...],    # Ditto.
            ...,
            ...,
            ...,
        ]

        - Each line for foo and z (above) hold data from one Group repetition.
        - Since the Group is anonymous (no dest), the groups must
          be shoved into the Opt dests.
        - If the Group had a dest, it would store ntimes=4 inner Results.

Flattening policy:

    - If an Opt does not have both plural nargs and plural ntimes, its data
      will be flattened by default, as shown in the table.

    - User can request non-flattened data or flattened data to reverse the
      usual defaults

    - Defaults are marked with ** in the two columns for 2+ ntimes.

    nargs | ntimes 0,1 | ntimes 2+ (flat)    | ntimes 2+ (non-flat)
    ---------------------------------------------------------------
    0     | bool       | [bool, ...] **      | [[bool], ...]
    1     | a1         | [a1, ...] **        | [[a1], ...]
    2+    | [a1, ...]  | [a1, ..., ..., ...] | [[a1, ...], ...] **

Duplicate dests within a Result:

    - Users can define specs with non-unique dests. An extreme example:

        <x>... [-x] <x> [-x <x>{2}]

    - In such cases, Argle will add another outer list to the structures
      documented in the table above.

        opts.x = [
            [X, ...], # <x>...
            bool,     # -x
            X         # <x>
            [X, X]    # -x <x>{2}
        ]

Parameters:

    - Summary of policy:

        - Follow the policy princples outlined above:
            - An Option with parameters is a subset of the larger
              topic of how to organized parsed data in a Result.

        - No inner-Result if the Option has a single dest for its parameters.

        - Use '_' dest for parameters with unnamed dests.

        - Bundle data when dests are non-unique (as done above).

        - A parameter-group creates an inner-Result for its content.

    - Single dest for all parameters.

        - Default: no inner-Result.
        - This is the most common use case.
        - A "single dest" includes the situation when all dests are unnamed.

        --age <yr>

            opts.age = YR

        --nums <n>...

            opts.nums = [N, ...]

        --paths <> <> <>

            opts.paths = [P1, P2, P3]

    - All parameters have uniquely named dests:

        - Default: inner-Result.

        --size <w> <h>

            opts.size = Result(w = W, h = H)

    - Named parameter-group:

        - Default: inner-Result for the Group data.

        --foo <x> bar=(<y> <z>)

            opts.foo = Result(
                x = X,
                bar = Result(y = Y, z = Z),
            )

        --bar xs=(<x1> <x2>) ys=(<y1> <y2>)

            opts.xs = Result(
                xs = Result(x1 = X1, x2 = X2),
                ys = Result(y1 = Y1, y2 = Y2),
            )

    - Named dests, not entirely unique:

        - Default: inner-Result, plus the same bundling approach discussed
          above to handle non-unique dests.

        --foo <x> <y> <x>

            opts.foo = Result(x = [X1, X2], y = Y)

    - A mixture of named and unnamed dests:

        - Default: store the unnamed data under the '_' attribute.

        --foo <x> <> <> <y> <x>

            opts.foo = Result(x = [X1, X2], y = Y, _ = [V1, V2])

    - Unnamed parameter-group:

        - Default: an extrapolation of the logic so far.

        --bar <b> (<x1> <x2>) (<y1> <y2>)

            opts.bar = Result(
                b = B,
                _ = [
                    Result(x1 = X1, x2 = X2),
                    Result(y1 = Y1, y2 = Y2),
                ],
            )

--------
parsed-data-with-context: Including Context with the Result
--------

Summary:

    - The parsed Result (aka opts) will be callable.
    - Using-facing attributes of Result will be defined by the user.
    - The Result callable takes a str name (wanted type of info).

API sketch:

    # Define a Parse with user-context.
    p = Parser(SPEC, context = dict(foo = 1, bar = 2))

    # Get parsed Result.
    opts = p.parse(ARGS)

    # Retrieve contextual information in a declarative fashion.
    c = opts('context')    # Context provided by Argle.
    p = opts('parser')     # The configured Parser.
    u = opt('user')        # User-defined Context.

    # Also default support to get Argle Context (non-declarative).
    c = opts()

    # Other args are delegated to the Context.
    f = opts('foo')        # Becomes => opts('context').foo

Context class:

    - Generic container of attribute-value pairs.
    - Based on types.SimpleNamespace.
    - With support for dict-like iteration and get-item.

The user context:

    - User supplies it when defining the Parser.

        p = Parser(SPEC, context = CTX)

    - The supplied CTX can be:
        - Dict (if so, Argle converts to a Context).
        - Context instance.
        - Other object (left as-is).

Rejected approaches:

    - In early planning work:

        - The Result contained only the parsed data.

        - That imposed annoying requirements on some callables:
            - Example: dispatch functions.
            - How many argument would they be passed?
                - Result
                - Parser
                - Current Opt
                - etc.

        - Analagous annoyances would affect user code:
            - They might want to pass just opts.
            - But sometimes they need the Parser too.

    - Then I considered making opts callable:

        - Avoids attribute name collisions entirely.
        - Could support more queries/behaviors in future.

    - But I balked when I read the mock-up code:

        - Does not read intuitively/declaratively.

            p = opts().parser

        - The user could help with intermediate variable naming, but a library
          should not rely on that:

            context = opts()
            p = context.parser

    - Then I decided to devote an attribute name to the context.

        p = opts.context.parser

        - But one of my README examples had a --context option.
        - So right out of the gate I was hitting naming conflicts.

    - I considered allowing the user to change the name of that attribute:

        p = Parser(SPEC, context_attr = 'info')

        - But that seems as hassle too.
        - One more thing for the user to forget.

    - I went back to the callable strategy:

        - But this time with a declarative approach, where the user supplied
          the name for the kind of information wanted.

--------
eager-attachment-at-bounary: Eager option attachment at repetition boundaries
--------

In the following example, the -z option will bind eagerly to the repeated
triplets of positionals.

    Grammar       : cmds=(<a> <b> <c> [-z]){2,7}
    Example input : A1 B1 C1 -z A2 B2 C2
    Result        : opts.cmds[0] = Result(a=A1, b=B1, c=C1, z=True)

That policy is consistent with greedy parsing elsewhere.

--------
spec-syntax-named-unnamed: Spec-syntax: named and unnamed arguments
--------

Positionals must be named:

    frob <a> <b> [<c>]

Option arguments can be named or unnamed:

                                        # opts.mode:
    frob --mode {group} {name} {n}      # - Data object with attributes.
    frob --mode {} {} {}                # - List.

--------
variants-needed: Variants: why they are needed
--------

Are variants needed give that the spec-syntax already has support for
alternatives? Yes: they provide several benefits, even if one could do without
them, strictly speaking.

Partial variants are a useful device to express some grammars more
conveniently.

Usage variants are a good mechanism for the user to help Argle generate more
readable usage text and more relevant portions of it in response to errors.

Variants can provide a low-config mechanism for subcommand-style programs to
provide subcommand help text.

Variants have been a useful concept, and their names convenient handles, when
thinking about and planning this project. That utility might come in handy
later.

So one might think of the following related concepts, from most general
to most specific:

    Group           # Any grouping of grammar elements.
    Alternative     # A grouping where the end-user should choose one.
    Variant         # An alternative that strongly affects usage text.

--------
general-name-assignment: General name assignment: needed after all
--------

Argle does need general destination assignment. At a minimum, it needs that
feature not just for Opt, but also for partial variants. And once you go that
far, you might as well generalize it.

Consider examples like neck-diagram (EX_NECK_DIAG; also EX_NAB). With
destination assignment for the outer group, the specific Opt destinations (cmd,
snum, syms, etc) will be nested underneath the 'commands' namespace:

    opts.commands = [
        Result(cmd = 'snum', snum = 6),
        Result(cmd = 'tuning', notes = ('E', 'A', ...)),
        Result(cmd = 'fret', syms = ('1', '3', '5')),
        ...
    ]

Without that outer assignment, the returned data would be grouped by the Opt
destination names -- which badly jumbles everything up:

    opts = Namespace(
        cmd   : ['snum, 'tuning', 'fnum', 'fret', 'fret', ...]
        snum  : ['6']
        fnum  : ['5']
        notes : [[...]]
        syms  : [[...], [...], ]
    )

--------
spec-syntax-complexity: Spec-syntax: is it too complex?
--------

To evaluate the question, I focused on the least intuitive aspect of the syntax
and compared it against the API-driven alternative:

Alternatives:

    - This is an easy call: syntax is intuitive and API usage for this
      situation is annoying.

    - This is a strong example of the superiority of spec-syntax for grammar
      configuration relative to API.

Quantifiers:

    - The ... is intuitive and practically a convention.

    - The {m,n} syntax directly mimics regex and is also quite intutive.

General name assignment:

    - This feature is powerful: it allows grammar variation when
      a positional or parameter takes a specific value.

    - Configuring such matters via the API requires the user to understand how
      the library works a bit too closely.

Partial variants:

    - API usage would require the user make multiple configurations to mark a
      variant as partial and then insert it wherever needed.

    - The partial syntax isn't heavy; in fact, it's moderately intuitve and
      without it, the spec-syntax might even be a bit less immediately
      understandable.

Zones and anchoring:

    - Decisions:
        - Infrequent use case.
        - Easy to handle via API.
        - Drop from spec-syntax.
        - Also see zones-not-needed

    - I suspect the desire for zones and anchoring is moderately low but still
      more than nothing.

    - Also, configuring these parameters via the API is simple to understand
      and requires little code.

    - While the zone syntax not too obtrusive, and it is a mixture of intuitive
      (zone markers) and not very intuitive (anchor markers)

    - Another question: is the zone concept needed, or could Group do the same
      thing? I increasingly think the latter.

Priority:

    - Setting this attribute is easy in the API.

    - Although the syntax is not heavy, it's also not fully intuitive.

    - The majority of use cases will get the built-in help behavior, and the
      library could interpret --help and --version options as priority
      by default.

    - Infrequent use case, easy via the API: let's drop it from spec-syntax.

--------
optional-positional-placement: Optional positionals before required are not a problem
--------

One might be concerned about Grammars containing optional positionals before
required ones. For example:

    [<m>] <x> <y>

But this is not a problem if we adhere consistently to greedy policy. If the
user wants positionals attached to <x> and <y> before <m>, they can express the
grammar differently.

--------
parsing-modes: Parsing modes
--------

Argparse background:

    - The argparse library has these modes:

        Allow unknown | Default-style      | Intermixed-style
        ------------------------------------------------------------------
        No            | parse_args()       | parse_intermixed_args()
        Yes           | parse_known_args() | parse_known_intermixed_args()

    - The methods allowing unknown arguments return a 2-tuple rather than
      a single Result, which is a bit inconvenient.

    - The default argparse style is overly restrictive.
    - Greedy parsing already support intermixed-style.

Argle approach:

    - Regular-parsing vs noconfig-parsing:
        - Determined by whether the user supplies a spec/grammar.
        - Parser():
            - spec: regular parsing
            - grammar: same, via API
            - nargs: noconfig-parsing with global nargs

    - Allow unknown arguments:
        - Done during the parse() call.
        - User tells where to store the unknown arguments.

        opts = p.parse(ARGS, unknown = DEST)

Additional notes on noconfig-parsing:

    - As elsewhere, Argle will use a greedy policy.

    - Positionals are not very relevant for no-config use cases:
        - They will be stored in one generic bucket.
        - The end-user can put them after the double-hyphen.
        - Other input will be options and parameters.

    - As a result, no ambiguous boundary questions arise and the end-user can
      control how parameters bind to options via their arrangement of
      arguments.

    - Optionally, the user can restrict such parameter binding by declaring a
      specific Quantifier as a global nargs.

Rejected features:

    - I consider supporting other ways to relax parsing
      beyond allowing unknown arguments.

    - For example, the user could allow invalid arguments (those that fail
      validation) or unconverted arguments (those that fail to convert).

    - These use cases do not seem compelling (and they might be a bit fraught).

--------
zones-not-needed: Zones not needed
--------

Problems with zones:
    - Concept was not useful in planning work.
    - A zone has no independent purpose: purely to support anchors.

Simpler approach:
    - Just use Groups.
    - Allow Opts to be anchored within them.
    - Handle that via API.

--------
dispatch-to-callables: Dispatching to callables
--------

Overview:

    - Kinds of dispatch:

        - Priority:
            - Any Option.
            - Triggered by presense among args, even if the parse fails.

        - Prompted:
            - Any Opt.
            - Get Arg input(s) via prompting.
            - Includes confirmation Opts (eg --yes).
            - Occurs only after successful parse.

        - Regular:
            - Any Opt.
            - Triggered by user supplying an Opt in a successful parse.

    - Special priority-flags:

        --help
        --version

    - Dispatch order:

        - Priority --help.
        - Priority --version.

        - Priority Opts.
        - Prompted Opts [discussed in separate sections].
        - Regular Opts.

        - Within the last 3 groups:
            - Default order = configuration order.
                - Parser will track order of dispatch configuration, by Opt.
                - If Opt has multiple callables: called in sequence order.
            - If needed, API can support modifying the order [TBD].

API summary:

    - Notation:
        - FUNC:
            - Single-argument callable.
            - Or a sequence of them.
        - FUNC_LOOKUP:
            - dict[str => FUNC]
            - Object where getattr('foo') => FUNC.
        - bool:
            - help:
                - True: use default Argle help function.
                - False: disable automatic support for --help.
            - priority:
                - True: use noop function.
                - False: disable priority status for --help or --version.

    - Special priority-flags:

        --help
        --version

        # Priority dispatch.
        p = Parser(SPEC, help = bool|FUNC)         # Default: True.
        p = Parser(SPEC, version = VERSION|FUNC)   # Default: None.

        # Regular dispatch.
        p.config('help', dispatch = FUNC, priority = False)
        p.config('version', dispatch = FUNC, priority = False)

    - Other flags:

        --examples
        --details

        # Priority or regular.
        p.config('examples', priority = bool|FUNC)
        p.config('examples', dispatch = FUNC)

    - Other Opts:

        --path <path>
        <age>
        <action=go|stop>

        p.config('age', dispatch = FUNC)
        p.config('action', dispatch = FUNC_LOOKUP)

Calling protocol for dispatching:

    - When dispatch occurs:

        - Priority:
            - After parse() finishes or fails.
            - Important consequence:
                - If any Option has priority.
                - And if that Option is present in Args.
                - Then failed parse() calls do not halt.
            - That consequence is the purpose of priority=True:
                - If the priority-option is present.
                - Do not halt in the face of a failed parse().

        - Prompted:
            - Only after a successful parse().
            - Before regular dispatch.

        - Regular:
            - Only after a successful parse().

    - Arguments pass to dispatch functions:

        - The parsed Result: opts.
        - The user can supply other data via user-Context.

    - Return values expected from callables for special-flags:

        - help and version:
            - False:
                - Argle will do nothing.
                - Dispatching continues.
            - Raise HaltDispatch:
                - Argle halts dispatching.
                - Program continues.
                - Details below.
            - Exit:
                - Program halts.

        - help:
            - True: default Argle help-text.
            - text: Argle will print it.
            - Section(s): help text for specific sections.
            - Two-tuple: (Sections, Variants): ditto, with specific usage-text.

        - version:
            - VER: default Argle function, using VER as the version string.

    - Handling of return values from dispatch functions:

        - Argle collects them in a returns-Context.
        - Stored under the relevant Opt dests.

        # Configure the parser.
        p = Parser(...)

        # Dispatch occurs after parse() finishes.
        opts = p.parse(ARGS)

        # User can examine return values from those calls.
        rs = opts('returns')

    - How a dispatch function can halt further dispatching:

        - Exit program.
        - Raise HaltDispatch. Argle will check two attributes:
            - exit_code:
                - Default = 0.
                - User can supply a positive int for unsuccesful exit.
                - Or None to suppress the exit.
            - msg:
                - Argle will print msg.
                - To stderr if exit_code is a positive int.

Why dispatch operates at the level of Opt, not Arg:

    - One could do it at the Arg-level, in theory.

    - But its seems implausible to want it:
        - Positionals: does not make a lot of sense.
        - Parameters: conceivable, but unlikely a frequent use case.

 Why "priority" couples two behaviors:

    1. Flexible parsing: simple membership test in ARGS.
    2. Dispatching priority.

    - The behaviors are coupled under the most comman usage scenarios:
        - Main examples are --help, --version.
        - Other known examples: --examples, --details.
        - If user wants priority with noop dispatch: priority=True.

Under what conditions does a dispatch function get called?

    - Dispatch always.
        - Is this even helpful?
        - The user could easily call the function themselves.

    - Dispatch if Opt is supplied.
        - I think this is the right approach.

    - Dispatch if Opt is supplied and non-required.
        - A bit too subtle.

Scepticism about the necessity of dispatch:

    - I have *never* found dispatching to be a difficult or annoying part
      of writing scripts.

    - Several easy approaches are readily at hand, and I usually pick the one
      that fits the script's grammar best.

        - Ordinary script with some special flags:
            - Basic conditional logic for the special flags.
            - Quite often the flags lead to early program exits.
            - Then just get down to business.

        - Situations where dispatch is driven by the value given for a
          primary Opt (eg, subcommand-style script).
            - Use a dispatch dict.
            - Use code to get the right callable via its name:
                - gettattr() if functions are in a class or module.
                - globals() if they are at the top-level in a script.

        - Situations where multiple functions are called (eg, steps).
            - Very similar the to previous situation.
            - But you are just calling a function for each of an Opt's
              plural nargs.

        - I have rarely needed anything fancier than that.

    - Relative to those basic approaches, can the dispatching API be simpler?

        - Any plan requiring heavy API knowledge is bad.
        - Users do not write scripts frequently enough to master the API.
        - They end up having to look it up every time.

    - Remember that it does not make sense to compare the Argle
      ease-of-dispatch to that of Click.

        - Click makes dispatch semiautomatic because it forces you to configure
          your parser at the functions themselves.

        - But that approach comes with unacceptable costs and drawbacks.

        - For Argle the relevant comparison is between a proposed API for
          dispatch and the roll-your-own alternatives.

Special support for regular subcommand programs:

    - An example:

        [<options>] <cmd=go|stop>

    - In a typical subcommand program, user wants <cmd> to drive 3 things:
        - Variant selection to drive usage-text.
        - Section selection to drive help-text.
        - Function selection for dispatch.

    - Argle will support this in two ways:

        - Full flexibility: user supplies their own callables:
            - Help and usage text: FUNC returns Sections/Variants.
            - Regular dispatch: dispatch dict tied to Opt(CMD).
            - These approaches are part of the API outlined above.

        - Configuration simplicity via naming consistency:
            - User names things consistently.
                - The <cmd> choices.
                - Names of Variants/Sections.

            - Help dispatch:

                p = Parser(SPEC, help = dispatch_with('cmd))

            - Regular dispatch:
                - No different/simpler than the flexible approach.

                p.config('cmd', dispatch = FUNC_LOOKUP)

    - Rejected approach:
        - User orders things consistently.
        - Help: list[Section/Variant] aligning with order of choices.
        - Dispatch: list[FUNC] aligning in the same way.

        - This approach offer false promise.
            - It is only marginally easier for the user to type.
            - Resulting code is more brittle, less declarative.

Motivation for priority dispatch:

    - Most options control the primary behaviors of a program.
    - But some are special, most notably those related to user help:

        --help
        --version
        --examples
        --demo

    - Argument parsing libraries often provide a convenient mechanism for:

          --help    (usually)
          --version (sometimes)

    - But that support tends to be not as convenient for users as it could be.

    - Consider a simple subcommand-style program.
        - The program has both general and subcommmand help-text.
        - Both <id> and <n> should be integers.

        demo [--help] [-n <n>] <action=print|delete> <id>

    - If end-user supplies --help, an argument parser should:

        - 1. Print help text and exit
        - 2. Select the help text that is relevant, given ARGS.
        - 3. Ignore errors in ARGS to the extent possible.

        - Examples of desired behavior:

            demo --help                # General help.
            demo --help delete         # Delete help.
            demo --help -n HI delete   # Same, in spite of invalid -n parameter.

        - Most argument parsers:
            - Do not easily support #2.
            - Fail on #3: they gripe instead of helping.

    - Argle addresses those problems with two mechanisms:
        - Priority options.
        - Flexible dispatching.

    - There are limits, of course.
        - Some bad input can reduce the accuracy of a best-effort parse.
        - If parsing halts at unknown -Q:
            - Either remaining ARGS will be ignored.
            - Or 'HI' will be interpreted as an invalid <action>.
        - Even item #3 above could be tricky:
            - 'HI' is an invalid <n> and will halt parsing.
            - How will Argle know to provide delete-help rather than
              general-help?
        - It is not clear how far it is worth it to pursue a super-relaxed form
          of parsing to glean more context for providing help.

Why priority-opts should be restricted to flags or Options:

    - Decision for now:
        - Restrict to Options.
        - Details TBD:
            - Mildly encourage users to restrict themselves to flags in docs.
            - Think more about best-effort forms of parsing.
            - Maybe restrict to flags later if such parsing seems not worth it.

    - Context:
        - If an opt has priority.
        - Its dispatching should occur no matter what.
        - Even in the face of otherwise invalid ARGS.
        - Example: --help.

    - But consider how parsing would work under those conditions:

        - Parsing of all ARGS fails.
        - Select variant that did the best (eg, max N ARGS consumed).
        - Argle populates a Result up to the ARG that failed.
        - What happens next?

        - If a priority-opt is a flag:
            - Parser is able to see that the flag is present.
            - The test is easy: '--help' in ARGS
            - It is able to locate the flag even if it occurs beyond the
              position (in args) where the parsing halted.

        - But if a priority-opt were allowed to be more complex:
            - With Args having grammatical/validation requirements.
            - How would Argle successfully parse the entity?
            - Parsing has already failed.
            - An Opt could be marked as priority, but that configuration will
              take effect only if the priority Opt appears to the left of the
              point (in args) where the parsing halted.

    - A possible counter-argument: let users do what the want:
        - If the parse fails.
        - Argle selects the best-performing interpretation.
        - Then populates a Result as best it can.
        - If a priority Opt is set, then invoke its dispatch functions.

        - In addition, the test for priority Options could be enhanced:
            - First perform a simple membership test: Opt.name in ARGS.
            - If yes:
                - Try to parse that Opt.
                - Starting just after the index of Opt.name in ARGS.
                - That allows for a peek beyond index where parse() halted.
            - That would allow for priority Option, such as:
                --details <topic>

Priority options: rejected naming alternatives:

    - My early planning used 'high-precedence': verbose; unnatural.
    - Click uses 'eager'.
    - But their concept deals mainly with dispatch ordering.
    - Click does not appear to support the concept of a priority-flag.

--------
prompting-for-var-inputs: Prompting end-user for var-inputs
--------

This is a form of dispatch, at least in its implementation protocol. It is a
bit different than regular dispatch in the sense that it occurs before the full
Result is available.

Examples: username, credentials.

    p.config('bar', prompt = PROMPT)
    p.config('bar', password = PROMPT)   # Prompt via getpass.getpass().

    Where PROMPT:
        - True:
            - Default Argle prompting.
        - MSG:
            - Same, but using MSG.
        - callable:
            - Called with opts (Result so far).
            - Should return VAL or raise.
            - The VAL will then go through the Opt's convert/validate/check.
        - (MSG, STREAM) tuple:
            - Args sent to getpass().

--------
confirmation-option: Supporting confirmation options like --yes
--------

Decision for now:
    - Deferred.
    - Seems doable within current plans for dispatching.
    - This would be a type of prompted Opt.

Click supports something called a confirmation option:
    - Example: --yes.

    - I presume it works like this:
        - End-user supplies --yes: no prompting occurs.
        - Otherwise, prompt the user before proceeding with dispatch.

Argle could support this under the dispatch umbrella:

    p.config('yes', confirm = CONFIRM)

    Where CONFIRM:
        - bool: if True, use default Argle prompt
        - MSG: same, but with the user-supplied prompt MSG.
        - (MSG1, MSG2): same, with user-supplied prompt-MSG and exit-MSG.
        - callable:
            - Takes opts as parsed Result.
            - Should return True to confirm.
            - If False, program exits.
            - If HaltDispatch is raised Argle will check and act accordingly.

--------
argparse-and-greed: argparse and greediness
--------

How argparse operates:

    - Attach arguments greedily.
    - Does NOT backtrack.

    Grammar:

        -z {}... <y> <y>

    Example input:

        -z A B C D E F

    Behavior:

        - Attach everything to -z.
        - Raise error because <y> not given.

--------
end-user-errors: End-user errors
--------

The problem:

    - Each Parser.parse(args) call will generate up to N failures, one per
      interpretation.

    - Ideally, we would report the error most aligned with end-user intent.

    - How do we select the error to report?

Initial ideas for mechanisms to select the most relevant error:

    - Error type, under the theory that some errors are more likely to
      convey intent about which alternative was (or was not) intended.

    - Percentage of input args matched, under regular parsing or
      perhaps forge-ahead parsing.

    - Percentage of available options present in the arguments, under the
      theory that the presence of options is one of the more telling indicators
      of intent. This metric is fairly easy to compute (a frequency distribution
      of options present).

Inferring intent from error types is tempting but not always so powerful:

    - Globally unknown options are an easy case: always select this error,
      because it's true under any interpretation.

    - One might think that an inapplicable option conveys that the current
      interpretation was not intended. But it's easy to create
      counter-examples: for example, a large N of arguments that work perfectly
      for the current interpretation, but the end-user inadvertently included
      an option for a different variant as the first argument (maybe when
      editing a prior command from shell history).

    - Invalid values might seem like an indication the current interpretation
      was intended, under the theory that the args were allocated to a slot but
      just failed in the details. But to know that with any confidence you need
      forge-ahead parsing.

The resolution is to consider how other parsers behave:

    - They always try to consume as much of the input as possible. This
      suggests that the first criterion for error-selection is to maximize the
      index of ARGS at which parsing halted.

    - Multiple interpretations can fail with the same index. To resolve ties,
      consider how errors can occur (consuming an OPT, consuming a POS, or
      during final checks). For each of those cases, the error-reporting
      precedence is fairly clear-cut [listed below].

    - To resolve ties, report the error associated with the earliest
      alternative, based on the grammar.

Types of errors in precedence order, by failure source:

    - Trying to consume an OPT:

        - Globally unknown option.

        - Inapplicable option for current alternative (but known to grammar).

    - Trying to consume a POS:

        - Conversion/validation problems: params.

        - Conversion/validation problems: positionals.

        - Excess arguments.

    - Making final checks:

        - Insufficient ntimes: option.

        - Insufficient ntimes: positional.

        - Insufficient nargs.

--------
converters-validators: Converters and validators
--------

Argle supports three concepts to check Arg inputs:

    - convert:
        - Takes a str direct from ARGS.
        - Returns a new value of the desired type.
        - Optionally, can also perform validation.

    - validate:
        - Takes a value (maybe str from ARGS; maybe a converted value).
        - Returns a bool to indicate whether it is valid.

    - check:
        - Takes an Opt and a Result.
        - Returns a bool to indicate whether the Opt is OK.

    - General notes:
        - The convert and validate operations are intended to perform basic
          operations on the ARGS supplied by the end-user. Hence a simple
          calling protocol focused on the values.
        - The check operation is intended to support broader checks that might
          require more contextual information, either about a full Opt (eg all
          of its Arguments or Parameters) or about an Opt in the context of the
          rest of the Result.

Calling protocol:

    - convert:
        - Takes STR.
        - Returns a VAL.

    - validate:
        - Takes a VAL.
        - Returns bool to indicate validity.

    - check:
        - Take a grammar element and the Result.
        - The element is typically an Opt, but could be Group or Variant.
        - Occurs at the end of the parsing process.
        - All Args have been converted/validated.
        - The full Result is known.
        - Returns bool to indicate whether the check is OK.

    - If convert/validate/check raise:
        - Argle will get MSG, if any, from the exception.
        - Build the end-user-facing error message, with MSG at end.

        - Other libraries require users to raise specific exceptions:
            - Examples:
                - argparse.ArgumentError
                - click.BadParameter
            - Seems like a needless hassle.

Support smart-types for convert/validate:

    - Supporting common use cases makes some sense.
        - Yes the user can write their own convert/validate.
        - But doing the common things well is handy.
        - Opens up support for more informative errors.
        - Similar in spirit to other Argle utilities:
            - Exiting with proper codes.
            - Printing errors in a consistent style.

    - Click:

        - The library provides various data-objects.
        - They hold configuration to perform convert/validate.

        - Examples:
              click.Path(...)       | Requirements to impose on a path
              click.File(...)       | Ditto, plus how to open the file
              click.IntRange(...)   | Min, max, etc
              click.FloatRange(...) | Min, max, etc
              click.DateTime(...)   | Allowed formats

--------
grammar-querying-api: Grammar querying API
--------

Why Argle needs flexible querying:

    - A Grammar can be a deep tree structure.
    - Users need to be able to retrieve element(s) of interest:
        - With minimal hassle.
        - Without having to have a deep understanding of the tree structure.

    - Element names are generally not unique IDs within a Grammar:

        - There are strong reasons behind that policy.

        - But in most use cases, users will want things with the same name to
          behave as if they were the same entity -- specifcally that they have
          identical configuration.

        - For that reason, bulk-configuration is a compelling need.

    - Bulk-configuration is a handy thing even without shared names:

        - It is a good way to less API burden on users.

Querying grammar elements in a Parser:

    - API:

        p.query(
            *paths,
            kind = KIND,
            exclude = KIND,
            attr = ATTR,
            negate = False,
        ) => Query

        - Where PATH:
            - A data-dive-like query path [details below].
            - Applied only against name and dest.

        - Where KIND:
            - Argle type: Opt, Section, Variant, etc.
            - Same, as a str.
            - Sequence of such things.
            - Default: None.

        - Where ATTR:
            - Attribute name to match.
            - Choices: name, dest, or both.
            - Default: both.

        - If negate=True:
            - Select entities that do not meeting the criteria.
            - Most likely useful as a subquery to filter out unwanted items.

    - Delegates the call to p.grammar.query().

    - The returned Query:

        - A collection of matching grammar elements.
        - Can be a target of further subqueries.
        - Supports a config() method to apply configurations to the elements.

    - PATH syntax:

        - Each PATH can contain 1+ query-paths, space delimited.
        - Each query-path contains 1+ elements, period delimited.
        - Each query-element is a glob-pattern.

    - Query-paths operate in a data-dive-like manner:

        - Each query-element will be tested against each candidate grammar
          element in generally this way:

            fnmatch(NAME_DEST, QUERY_ELEM)

        - The query-element can use a restricted glob-syntax:

            ? for single character
            * 0+ characters

            - To keep spec-parsing and query-path-parsing reasonable, other
              glob-syntax features are not supported.
            - Thus the character set for a query-element is limited:
                - valid-name characters: leters, digits, underscore, hyphen.
                - integers
                - basic glob markers: ? and *.

        - When a PATH has multiple elements, they are interpreted in a flexible
          nesting fashion to embrace both:

            - Direct nesting: parent to child
            - Extended nesting: any grandparent to child.

        - Example:

            bar.fubb.foo

            - Get the grammar elements with name/dest of 'foo'
              that are hierachically nested as follows:

            bar
                ...
                    fubb
                        ...
                            foo

    - Integer path elements operate differently:

        - Performs a get-via-index operation (details below).

        - Example:

            p = Parser('<x> [-x]')
            p.query('x.1')

            - Gets the 2nd Opt.

    - Multiple query paths:

        - Combined in an OR-wise fashion.

Why integer PATH elements behave differently:

    - Name-like PATH elements (dest or name) perform an
      any-nesting subquery.

    - Integers perform a direct get-via-index operation.

        - If they behaved in the regular fashion it would be bad:
            - A PATH of 'foo.2' would get any elems[2] nested underneath.
            - Seems fraught for a user to reason through.

        - More intuitive is to interpret the integers as direct indexes into
          elements the user can see in a visual inspection of the spec.

    - The integer need not be last path-element: 'foo.2.bar'

    - Example:

        - The grammar has three -x flags that need different help-texts.
        - The user can see how those Opts are ordered in the spec.
        - Their spec-scopes can simply index into that ordering.

        --foo [-x] | --bar [-f] [-x] | --blort [-x]

        x.2 >> [-x] : blah x-for-blort
        x.0 >> [-x] : blah x-for-foo
        x.1 >> [-x] : blah x-for-bar

Possible query helpers:

    - Getting exactly one:

        query_one(PATH)
        query(PATH, one = True)
        get(PATH)

    - Getting specific kinds of grammar elements:

        query(PATH, kind = 'Section')
        query_section(PATH)

    - Tenative decisions:

        - Use get() to query for exactly one.
        - Rely on kind; do not expand the API footprint.

--------
validation-notes: Validation notes
--------

What to validate:

    - Only user-facing code: the entry points.

    - Let internal code blow up if given bad input.

Consider using a library:

    - valid8 is interesting but seems a bit over-engineered.

    - Its docs point to other tools that could have interesting ideas.
        - I briefly checked them.
        - Common patterns I dislike:
            - Specifying validation via decorators, docstrings, annotations.
            - Elaborate DSL syntaxes.

Consider implementing a simple validation module for the project:

    - Some of the libraries I saw treated the process very formally, with a
      large API to learn.

    - A simpler approach seems better.

        validate(
            value,      # Value to check.
            convert,    # Callable: value => converted-value
            validate,   # Callable: converted-value => bool
            error,      # Error to raise.
        )

Where should validation logic reside?

    - Option 1: near the call site, so that you do not have to look elsewhere
      to understand the function.

        - Using decorator. Validation library writers seem attracted to this
          approach, but I don't see the appeal. It does not save any typing,
          and I find decorators with a lot of content to be awkward looking --
          aesthetically unappealing.

            @validate(
                x = (
                    int,
                    lambda x: x in range(1,11),
                    'x parameter must be interger 1 through 10: {val}',
                ),
                y = (...),
                z = (...),
            )
            def bar(x, y, z):
                ...

        - Or just using an ordinary function:

            def bar(x, y, z):
                validate(
                    x,
                    int,
                    lambda x: x in range(1,11),
                    'x parameter must be interger 1 through 10: {val}',
                )
                validate(y, ...)
                validate(z, ...)
                ...

    - Option 2: put validation logic a separate module, consolidating such
      details in one location. Let readers focus on the happy-path substance of
      the function, not the grubby validation logic, exception raising, etc.
      That code is mostly formulaic anyway -- stick it in the footnotes.

            # Main code.

            @validate
            def bar(x, y, z):
                ...

            # Validation module:

            register_validators(
                bar = (
                    x,
                    int,
                    lambda x: x in range(1,11),
                    'x parameter must be interger 1 through 10: {val}',
                ),
                ...
            )

        Under this approach, you want the validators to be composable, with the
        ability to define a bigger validator using smaller validators.
        And such compositions may need some helpers:

            validate_all()

--------
strategy-reassessment: Reassess the strategy
--------

After further reflection and looking again at the various job-client example
scripts (EX_JOB_CLIENT), I realize I underestimated the power of the text-based
configuration syntax.

    - It's true that I did find writing the literal help text tedious. I also
      disliked the idea that it would lack dynamic formatting behavior.

    - However, the API based configuration is very ineffecient and repetitive
      compared to the brevity, clarity, and intutiveness of the text approach.

    - Perhaps the right path, again, is to used text-driven configuration, but
      as syntax, not literal help text.

Consider which parts of the ultimate help text must be typed directly by the
programmer:

    - Option or argument names.
    - Help text for each option/argument.
    - Metavars.
    - Aliases.
    - Section names.
    - Choice values (if simple strings).

The simplest, clearest way to write that material is as a block of options
text. Lines likes these cover most of those bases:

    General::
    --job-id -j ID    : The job id.
    --od-user -u USER : Open Directory user who submitted the job.

The only other configurations are (a) syntax for complex grammars, and (b)
stuff well handled by the API (defaults, types, conversion, validation,
dispatch, sometimes choices, etc).

And this text-centric approach is flexible in allowing a variety of
usage patterns:

    - It can be treated as literal options text, for those who prefer that
      approach. Essentialy, Argle will support a Docopt mode [less certain
      about this now].

    - But treating it as configuration syntax will be easier for many who (1)
      don't want to have to lay everything out precisely and (2) especially
      don't want to have to define a usage grammar even for programs with
      standard command-line needs. If the API approach is ineffecient
      generally, the literal-text approach is ineffecient in requiring a usage
      grammar every time (as docopt does).

The write-up will need to be reframed to emphasize the debt to the text-based
argument parsers and to criticize the API approach for being so inefficient. In
the writeup place greater emphasis on some practical examples illustrating the
superiority of the text-based approach over argparse.

--------
opt-spec-subset-of-spec-syntax: Opt-spec syntax is a subset of the spec-syntax
--------

Opt-specs use a grammar subset, not an alternative grammar:

    - Implication: options are not assumed to be optional.
    - Square brackets required if intended.

Supported subset of the full spec-syntax:

    name
    dest
    nargs
    ntimes
    choices
    aliases
    help

Opt-spec lines can be confused with unnamed variants:

    - The issue is fundamental.
    - Not really addressable via extended peeks or other fancy parsing.
    - Example: 3 variants or 3 bare-bones opt-spec lines?

        pgrep
        <rgx>
        --ignore-case -i
        --invert-match -v

Resolving the confusion:

    - First, note that the ambiguous examples are not compelling use cases.

    - Second, rely on a greedy parsing policy.

        - In first section, first look for variants.
        - Anything that could be a variant will be interpreted that way.

        - If user is unhappy with the parser:
            - The configuration problem is easily noticed
            - Also easily fixed: add a trailing colon to the first line that
              should be treated as opt-spec rather than variant.

    - Rationale:

        - The most common use case is to derive grammar from 1+ opt-specs.
        - It works well for many standard grammar needs, and opt-spec is more
          featureful than variant (because it supports aliases and help text).
        - So the no-variant use case should have the least hassle.

--------
help-text-as-format-strings: Help text elements as format-strings
--------

When writing help-text elements, a user sometimes needs to refer to data that
is best known to Argle. Some common and conceivable use cases:

    - Opt help-text:
        - List the choices.
        - State the default.

    - General help-text:
        - List or mention subcommand choices.
        - Document usage variants, in situations where the usage-text generated
          by Argle uses a symbolic name (eg, separator based grammars).

API overview:

    - User configures Parser:

        p = Parser(SPEC)
        p.config(...)

    - User tells Argle to format the help-texts.

        p.format_help_texts(**kws)

    - What Argle will do:

        - Traverse the Grammar.
        - Call str.format(self = self, **kws) on all help-text elements.
        - Where self is the configured Parser.
        - Elements having formatting-braces will be augmented.
        - Those without them will be unchanged.

    - Syntax supported in the formatting-braces:

        - Generally: regular Python using the regular Argle API.

        - Plus support for an abbreviated syntax for opt-specs:

            - OPT will be replaced by the syntax to get() the needed element
              (Opt, Arg, or Choice).

            - Example:

                [--style <s>] : Set style to {OPT.choices_help}

            - During spec-parsing, Argle will convert the help-text for
              that Opt into the following:

                Set style to {self.get('style').choices_help}

            - Then the user's subsequent call of format_help_texts() will do
              the right thing.

A few API conveniences:

    - choices_help: the choices, comma-delimited:

        'foo, bar, fubb'

    - choices_default_help: same, followed by default:

        'foo, bar, fubb [default: foo]'

    - usage_text: usage text for any grammar element.

        - See example below.

A more complex example: documenting partial variants:

    - Consider EX_NAB, which has the following variants:

        - The variants.

            [--trace] commands=(chomp! | findall! | grep! | range! | run!)...
            --help

        - API:

            p.config('commands', name = 'command')

        - The usage-text.

            nab [--trace] <command>...
            nab --help

    - How will user document the actual grammar, which lives in the partials?

    - One approach is to document them using format_help_texts():

        - Add the following to the SPEC, after the variants

            Where <command>:::
                {p.get('chomp').usage_text}
                {p.get('findall').usage_text}
                ...

        - The usage-text:

            nab [--trace] <command>...
            nab --help

            Where <command>:
                chomp
                findall <rgx> [-a]
                ...

    - Another approach: unnamed Group, plus an indented usage style:

        - This will cause Argle to document the full grammar explicitly.
        - That will make the usage less readable.

        - But the user could tell Argle to use an indented style for
          the main Variant, producing something like this:

            nab [--trace] (
                    chomp |
                    findall <rgx> [-a] |
                    grep <rgx> [-i] [-v] [-s] |
                    range <start> <stop> [<step>] [-g] |
                    run <code> [-g <>] [-a] [-v] [-i]
                )...
            nab --help

        - For now, this API possibility is deferred.

--------
var-input-representation: Representing var-inputs in spec-syntax
--------

There are four common styles for representing variable end-user input, along
with some differences in details for specific implementations, especially as it
relates to choices:

    Style     | Parameters  | Positionals | Choices | Examples
    ----------------------------------------------------------------------------
    Angle     | <>          | <>          | {}      | git, picocli
    Sensitive | UPPER       | lower       | {}      | argparse, many Python/Ruby
    Lower     | lower       | lower       | () []   | POSIX, many Unix utilities
    Upper     | UPPER       | UPPER       | () [] ? | rsync
    ----------------------------------------------------------------------------
    Docopt    | <> or UPPER | <>          | () [] ? | .
    Argle     | <>          | <>          | <>      | .

    - Unclear how docopt and rsync handle choices, but I think they use
      parens/brackets.

Upper and lower styles: easily rejected:

    - They work poorly for positional variants and parameter variants.

    - Usage text is ambiguous: we cannot distinguish merge/delete (literal
      values for positional variants) from path (variable input).

        frob [-f] merge [-x] [-y] path
        frob [-f] delete [-z] path

Sensitive style: better but not fully robust:

    - It handles most situations:

        frob [-f] merge [-x] [-y] PATH
        frob [-f] delete [-z] PATH

    - And the Python/Ruby community is accustomed to it.

    - It does fail if the variant values need to be uppercase. Some type of
      quoting or other syntactic workaround would be needed:

        frob [-f] `MERGE` [-x] [-y] PATH
        frob [-f] `DELETE` [-z] PATH

Angle style: robust due to greed:

    - In order to produce robust usage text for variants, literal inputs need
      top precedence.

    - More generally, treating text (whether in spec-syntax or usage text)
      as literal by default, it an good baseline (eg, that is how regex works).

    - The conclusion is that variable inputs must be enclosed, making
      case-based solutions either flawed or insufficiently robust.

    - Argle was drifting toward {param} and <pos> as the enclosures:

        - That would also be an odd combo. The only precedent is docopt,
          which supports it only as an alternative syntax.

        - In addition, braces have a semi-conventional role for choices in
          tools like argparse, so using them for parameters would be
          anti-conventional.

    - Will there be ambiguities if parameters and positionals have the
      same enclosure?

        --point <x> <y>   # How many parameters?

    - Initially, I thought that parentheses/brackets could resolve such matters
      (see Git usage text, for example). But the brackets do not solve the
      problem by themselves. For example, is this an optional option with 2
      parameters or an optional group with a flag and 2 positionals?

        [--point <x> <y>]

    - Once again, embracing a greedy policy sorts everything out. If parameters
      bind eagerally to angle-bracketed inputs, then the example above is a
      2-parameter option.

Verdict: angle style:

    - The clarity of the approach seems to more than counterbalance the
      small increment of extra typing: all variable inputs are enclosed in
      the same way (positionals, parameters, and thus choices).

    - The approach has strong precedent, especially from Git.

    - Brackets and greedy will sort out any ambiguity:

        [--point <x> <y>] <z>  # 2-param option, required positional.

    - If needed later, support other styles for usage text and grammar
      syntax (especially sensitive).

--------
enhanced-quantifiers: Enhanced quantifiers
--------

Quantifiers could be more featureful:

    - A third parameter similar to a range step:

        <x>{0,6,2}      # 0, 2, 4, 6

    - Ability to support noncontiguous quantities:

        <x>{!1,2,3,5}   # 1, 2, 3, or 5

--------
opt-specs-and-opt-descs: Opt-specs and opt-descs
--------

Definitions:

    - opt-spec:
        - Configures an Opt in the spec.
        - Here Opt is defined broadly to include:
            - The Opt itself: name, args, params, quantifiers, etc.
            - Aliases.
            - Help text:
                - For the Opt.
                - For child elements of the Opt.
                    - Parameters.
                    - Arg choices.

    - opt-desc:
        - An opt-spec becomes an opt-desc in the user-facing help-text.
        - Can have different formats:
            - default (eg similar to argparse).
            - manpage.
        - Does not include quantifiers (unlike an opt-spec).

    - opt-listing:
        - A list of opt-specs (in the spec) or opt-descs (in help-text).
        - Preceded by a heading (by default).

Opt-descs: other terms considered:

    - Opt-spec: fails to distinguish the two contexts (spec vs help-text).
    - Opt-text: but we also have Opt.text.
    - Opt-help-text: same problem.
    - Opt-doc: "documentation" for an Opt; but sounds too much like docopt.
    - Opt-listing: that term already in use in a collective sense.
    - Opt-desc:
        - Provides a nice contrast: opt-spec becomes opt-desc.
        - Opt-desc is a bit different that a full opt-spec, in the sense
          that it includes no quantifers.
        - ChatGPT implied that "option description" is used in the
          command-line documentation tooling community but that did not
          jump out immediately in my very brief web searches.

Opt-descs: why they excludes quantifiers:

    - Summary:
        - Opt-specs fully configure the Opt, with quantifiers.
        - But opt-descs exclude the quantifiers.
        - That aligns with other libraries (eg arparse).
        - Rationale:
            - Usage is responsible for grammar.
            - Opt-descs document the Opt, its parameters, and their choices.

    - Mockups: quantifiers for parameters:

        - With quantifiers:

            --blort [<b>]               Blah blah
            --nums <x> [<y>]            Blah blah
            --vals <a> <b>{1,3}         Blah blah
            --point <x> (<y> <z>)...    Blah blah

        - Without quantifiers:

            --blort <b>                 Blah blah
            --nums <x> <y>              Blah blah
            --vals <a> <b>              Blah blah
            --point <x> <y> <z>         Blah blah

    - The benefit of including quantifers in the opt-descs is that the
      default policy of using the placeholder [<options>] in the usage-text
      remains viable.

        - The usage grammar is still clear.
        - Because in simple cases, all of the options represented by the
          placeholder are indeed optional, with ntimes=(0,1).

    - But quantifiers applied to individual opt-descs can break down:

        # The spec: Opts in a quantified Group.
        [<a> <b>]...

        # The quantifier cannot be accurately expressed via single opt-descs.
        [<a>]...         Blah blah
        [<b>]...         Blah blah

        - The fallback policy could be: exclude enclosing-Group quantifiers.
            - That might be reasonable.
            - But examples like these illustrate that individual opt-descs are
              not up to the task of fully conveying grammar in complex cases.

The <options> placeholder, opt-descs, and quantifiers:

    - Summary:
        - Leave it hands of the user.
        - Let user disable options_summary if they want.
        - Let the user supplement Opt help text to clarify grammatical details.

    - The <options> placeholder implies that all options take a simple form:

        - All options having the same optional-vs-required status:
            <options>
            [<options>]

        - With no other grammatical complexity.
            - Opt.ntimes.
            - Parameter.ntimes.
            - Opt coupling via enclosing groups.

        - Since the opt-descs cannot document such complexities, use of the
          placeholder would mean that the grammar of the Opts is documented
          nowhere in the help text.

    - One might be tempted to adopt a restrictive policy:

        - Use the placeholder only if certain criteria are met.
        - If not, disable options_summary.

    - But see the repo mockup:

        - The usage-section has [<general-options>], as configured via SPEC.
        - But one of those options has an unavoidably complex form:

            [--config <key> <value>]... : Overrides a config key/value pair

        - If you just strip away the quantifiers you get this:

            --config <key> <value>        Overrides a config key/value pair

        - The only way to convey the actual grammar is via the Opt's
          help text, eg via a trailing remark:

            # User could write the text.
            Overrides a config key/value pair (repeatable)

            # Argle could attempt to do so, but this seems fraught.
            Overrides a config key/value pair (0+)

        - Or Argle could include the quantifiers in complex cases:

            [--config <key> <value>]...   Overrides a config key/value pair

        - The example script comes from the Click project. Click does not deal
          with this issue at all, leaving it in the user's hands.

Documenting Parameters and choices:

    - Opt-specs and opt-descs can document an Opt's "child elements".
        - Parameters (of Option).
        - Choices of an Arg (Argument or Parameter).

    - Syntax:
        - The scoping syntax is used to declare the parent-child relationship.
        - But in this case, the scope needs no query-path.
        - Schematically:

            parent-opt-spec
            >> child-opt-spec-1
            >> child-opt-spec-2
            ...

    - Documenting Parameters:

        # Example opt-specs.

        --point <x> <y> : Blah point
        >> <x>          : Blah x
        >> <y>          : Blah y

        # Corresponding opt-descs.

        --point <x> <y>   Blah point
          <x>             - Blah x
          <y>             - Blah y

    - Documenting choices:

        # Example opt-specs.

        --step <op=add|subtract> : Blah op
        >> <op=add>              : Blah op-add
        >> <op=subtract>         : Blah op-subtract

        <action=go|stop> : Blah action
        >> <action=go>   : Blah action-go
        >> <action=stop> : Blah action-stop

        # Corresponding opt-descs.

        --step <op>          Blah op
          add                - Blah op-add
          subtract           - Blah op-subtract

        <action>             Blah action
          go                 - Blah action-go
          stop               - Blah action-stop

    - Doing both:

        # Example opt-specs.

        --mode <speed=fast|slow> <vol=loud|quiet> : Blah mode
        >> <speed>                                : Blah mode-speed
        >> <speed=fast>                           : Blah mode-speed-fast
        >> <speed=slow>                           : Blah mode-speed-slow
        >> <vol>                                  : Blah mode-vol
        >> <vol=loud>                             : Blah mode-vol-loud
        >> <vol=quiet>                            : Blah mode-vol-quiet

        # Corresponding opt-descs.

        --mode <speed> <vol>    Blah mode
          <speed>               - Blah mode-speed
            fast                  - Blah mode-speed-fast
            slow                  - Blah mode-speed-slow
          <vol>                 - Blah mode-vol
            loud                  - Blah mode-vol-loud
            quiet                 - Blah mode-vol-quiet

    - In the manpage style, child-elements will be documented using the
      indentation one might expect. For example, <action=go|stop> would
      like like this in a manpage style:

        <action>
            Blah blah blah blah blah blah blah blah blah
            blah blah blah blah blah blah.

            go
                Blah blah blah blah blah blah blah blah
                blah blah blah

            stop
                Blah blah blah blah blah blah blah blah
                blah blah blah

    - Why the scoping syntax is needed:

        - If one focused purely on documenting choices, one could avoid the
          need for the scoping syntax.
        - The policy regarding opt-spec unification for opt-specs involving
          choices would be sufficient.
        - But to document Parameters themselves, the scoping syntax is needed
          to declare the parent-child relationship.
        - Otherwise, each opt-spec would be interpreted an independent Opt.

    - I considered requiring the API to document child elements:

        - But that seems ill-considered.

        - Opt-desc help-text belongs in the spec:
            - Inherently involves textual information.
            - And is implicated in page layout details.

        - The API is not much clearer than the spec syntax:

            --point <x=a|b> <y=c|d>

            # Text for <x> parameter.
            p.config('point.x', help = 'blah blah point-x')

            # Text for <x=c> parameter. Not clear how API would work
            ...

OO model: where do help-texts of child entities reside?

    - Example:

        <action=go|stop> : blah-action
        <action=go>      : blah-go
        <action=stop>    : blah-stop

    - Model:

        Positional(action, help='blah-action')
            Arg.choices = [
                Choice(value='go', help='blah-go'),
                Choice(value='stop', help='blah-stop'),
            ]

Where to configure aliases in an opt-spec:

    - I considered adding a rule to require that the aliases, if any, reside
      separate from the grammar of the Opt configuration. An illustration:

        -f [--foo <>]          # OK.
        -o (--opt <> <>){3}    # OK.

        [-f --foo <>]          # Not OK: the -f alias should be outside brackets.

    - But the rule seems needlessly touchy. Since configuring a single Opt
      already requires nearly the full grammar, it makes more sense to parse
      the line as follows:

        expression [: [help-text]]

    - Then examine expression to extract any aliases and validate that it
      configures only a single Opt.

Can a grammar include arg-variants based on parameter choice combos?

    - Strange use case ... but I think current plan could handle it.

    - Spec:

        --point <x=a> <y=c> [--ac]
        --point <x=a> <y=d> [--ad]
        --point <x=b> <y=c> [--bc]
        --point <x=b> <y=d> [--bc]

    - Usage:

        --point a c [--ac]
        --point a d [--ad]
        --point b c [--bc]
        --point b d [--bc]

--------
group-level-validation-needed: Why Group-level validation should be retained
--------

If focusing just on ntimes, one might be tempted to collapse Group validation
needs (primarily ntimes) down to the Opts. Some of the discussion in
parsed-data-structure, for example, loosely speaks in such terms.

But the Groups do impose their own requirments. In this example, the ntimes of
the Opts are inter-linked: if any one appears, the requirements of the others
changes dynamically.

    [ -x -y [-i] ]

But Groups do have other attributes: dest and maybe validate. And it seems
difficult to imagine all consequences of grammar flattening. Every time I
experimented with it in the past, problems were encountered. It is possible
that a Target might flatten Group-level ntimes down to the Opts purely for
convenience during argument-parsing. But it seems important to retain the
ability to impose requirements at the Group level rather than only at the Opt
level. Finally, because Groups can nest, storing their requirements at the Opt
level is not immediately straightforward.

--------
usage-section-spec-syntax: Usage section in the spec-syntax
--------

Why spec-syntax does not allow a title for the usage-section:

    - An example spec:

        Blort ::

        <path> : Blah blah

    - Ambiguity:

        - Does the configuration to apply to usage-section?
        - Or the first regular section?

        - The spec-syntax provides no way to convey that.
        - One could add more syntactic elements.
        - But the most recent spec redesign tried to simplify the syntax (eg
          eliminating prog from the spec).

--------
usage-text-and-named-groups: Usage-text and named groups or choices
--------

Usage text can contain named collections of elements:

    - Named Group of Opts.

        other-options=([--foo] [--bar] [--fubb] <path>)

    - Choice values: arg-variants.

        <action=walk|run|freeze>

Previous plans envisioned Argle documenting such things in usage-text:

    - Automatically documenting the named collections of opts or choices.

    - Example:

        - Spec:

            runner <action=run|walk|rest> [-n]

        - Usage-text:

            Usage:
              runner <action> [-n] [help-options]

              Where <step>:
                run
                walk
                rest

              Where help-options:
                --help
                --examples
                --details

But that raises too many detailed questions:

    - Layout, ordering, labelling via headings, etc.
    - Too many details and possible scenarios.

    - Let the user handle it:
        - Ordering of opt-specs.
        - Headings for opt-spec listings.
        - Additional text before/after/among the opt-specs.

--------
headings-in-spec-syntax: Spec-syntax support for headings
--------

Spec-syntax needs headings in addition to sections:

    - Sections organize the help text and provide a mechanism for more
      context-sensitive help text.

    - Headings are a way to provide an organization device within
      a section (loosely akin to sub-sections).

    - Syntax:

        Section-foo ::

        Heading-bar :::

Rationale:
    - Planning notes use the heading concept a lot.
    - I needed them multiple times when doing mock-ups.

    - Opens up ability to support consistent styling for headings.

    - Opens up an automatic-heading policy:
        - See below.

    - Eliminates need to block-quote heading text.
    - The new heading syntax is simple enough and reasonably intuitive.

Automatically generated headings for opt-spec listings:

    - Policy:

        - If an opt-spec listing has no heading immediately before it.
        - Then Argle will generate one.

        - User can override in two ways:
            - Put their own heading in front of the listing.
            - API call to suppress auto-heading (details TBD).

    - Common scenarios in a usage-section:

        - Just variants and opt-specs (no blocks-quotes).
        - Argle should generate default headings for such scenarios.

            Arguments:
              <foo> : Blah-foo
              ...

            Options:
              [--level <n>] : Blah-level
              ...

    - Similar logic in other sections:
        - Will be common for a section to have nothing more than a section
          title, maybe some block-quoted text, and then an opt-spec listing.
        - Argle should attach standard headings to those listings.

Triple vs double colons for headings:
    - Why not triple-colon for sections, since they have higher status?
    - Better to having N colons convey depth in hierarchy.
    - Leaves open possiblity of supporting subheadings.

--------
arg-choices-in-usage-text: Arg.choices in usage-text
--------

Policy under most circumstances:
    - An entity is represented by its name in usage-text and spec.
    - Under most circumstances, that is true for Args.

But when an Arg has either choices or choice, things change:

    - Arg with choices:
        - Use the name, if defined.
        - Otherwise, use choices as a stand-in for the symbolic name.

    - Arg with a choice:
        - This occurs in arg-variants.
        - Use the choice in usage-text, even if a name is defined.
        - Explanation:
            - Policy appears to deviate from normal.
            - That appearance is deceptive in the case of arg-variants.
                - The choice is no longer a var-input.
                - It is a literal-input.

    - Arg with no choices and no name:
        - Represented as an anonymous-input in usage:

            --point <> <>

--------
groups-need-names: Why Group needs both dest and name
--------

Why Group needs a dest:

    - Example: EX_NAB.

    - Without a Group.dest (commands in this case) Argle would have no way to
      store the information other than via the Opt dests.

       - Data would be organized in a narrowly correct but impractical way.

       - Every dest would be a flat list of values, some of them coming from
         different 'cmd' invocations.

        Result(
            debug = D1,
            help  = H1,
            cmd   = [chomp, findall, grep, grep, range, run],
            rgx   = [       R1,      R2,   R3              ],
            i     = [                I1,   I2,          I3 ],
            v     = [                V1,   V2,          V3 ],
            s     = [                S1,   S2              ],
            start = [                            X1        ],
            stop  = [                            Y1        ],
            step  = [                            Z1        ],
            g     = [                            G1,    G2 ],
            code  = [                                   C1 ],
            a     = [       A1,                         A2 ],
        )

        - Even if one could imagine a policy statement like "put data for a
          Group in an inner-Result", the problem remains that Argle has no
          attribute name (no dest) to which to allocate the inner-Results.

        - Other default policies (eg, invent formulaic dest) seem inelegant.

    - Setting a Group.dest produces a sensible Result:

        Result(
            debug = d1,
            help  = h1,
            # Each Result is a column in the tabular arrangement above.
            commands = [
                Result(chomp),
                Result(findall, R1, A1),
                Result(grep, R2, I1, V1, S1),
                Result(grep, R3, I2, V2, S2),
                Result(range, X1, Y1, Z2, G1),
                Result(run, I3, V3, G2, C1, A2),
            ],
        )

In early planning work, Group had dest but no name.

    - The equal sign looks like an assignment.
    - Which implies that 'mode' more dest than name.

        <mode=fast|slow>

    - I knew Groups required a dest, in order to achieve reasonable
      data-storage in more complex grammars (EX_NECK_DIAG)
    - But I did not yet have a clear purpose for Group.name.

    - In addition, I had not come to a full understanding of the meaning of the
      name attribute across all grammar entities.
    - Namely, that the 'name' is the primary decide to represent the entity
      both in usage-text (directly) and the API (via queries).

Argle users can achieve various usage-text styles for Groups:

    - Compact, readable style:
        - Use a named group.
        - Tells Argle to represent the Group symbolically in usage.

    - Fully-explicit style (no inner-Results):
        - Use an unnamed Group in the main variant-def.

    - Fully-explicit-style (with inner-Results):
        - Use a named group in the spec.
        - Plural name would be advised in this case (commands), because the
          user mainly cares about the dest.
        - Then unset the Group.name via API.

            p.config('commands', name = None)

--------
degenerate-groups: Degenerate groups with only one element
--------

Groups with one element will occur often:

    - One optional thing in square brackets:

        [--foo]
        [<z>]

    - One required thing in parentheses for disambiguation:

        --point <x>     | Option with one parameter
        (--point) <x>   | Flat and one positional

In the spec-syntax, single-element groups exist for good reason:

    - But when the parsed spec is converted into the actual
      Grammar instance, degenerate groups will be dropped.

    - And the group's quantifier will be applied directly to the single
      element.

--------
settings-and-opts: Opts and settings (preferences and environment variables)
--------

Data values in a parsed Result can come from various sources:

    - Settings:
        - Preferences: a config file.
        - Environment variables.

    - Parser configuration:
        - Regular default values.

    - End-user inputs:
        - Command-line arguments.

Settings are upstream inputs:

    - Settings give the appearance of being a kind of default:

        - User sets a default in a preference file.
        - User replaces it with a default in an environment variable.
        - That default might or might not be replaced via CLI arguments.

    - Settings are more correctly viewed an alternative form of input.

        - A value from settings does not replace a configured default.
        - Rather, it simply supplies the value.
        - So the Parser ignores the configured default.

    - Settings, in effect, are upstream inputs.

Two goals for Argle related to settings:

    - Adjusting parsing requirements based on settings:

        - Example:
            - A required Opt.
            - Provided via settings.
            - Parsing should understand that the requirement is met.

        - Such considerations can be applied during arg-parsing.
        - But do not apply them when generating usage and help text.

    - Merging settings and the parsed Result.

        - Can be a hassle with argparse (eg mvs).
        - Argparse does not report a value's provenance: default or ARGS.

        - Argle will:
            - Make the merging unnecessary for most use cases.
            - And provide provenance info to support complex merging that a
              user might need to perform.

Applying settings to the Parser:

    - Code sketch:

        # User loads their own settings.
        # If needed, user adjusts them to align with Parser names/dests.
        PREFS = ...

        # User configures Parser, telling Argle about upstream inputs.
        p = Parser(SPEC, prefs = PREFS, envs = ENVS)

        # Or user can apply such settings to specific Opts.
        p.config('foo', pref = PREF, env = ENV)

    - Where PREFS:

        - Dict:
            - key: query-path to identify 1+ Opts.
            - value: to be set.

        - For each Opt, set Opt.pref.

    - Where ENVS can be:

        - None (the default):
            - Argle will do nothing regarding envvars.

        - True:
            - Envvar names must agree with Opt dests.
            - With env vars in uppercase (of course).

        - FMT:
            - Format string for the envvar name.
            - It should take one parameter (ie the Opt.dest).

        - dict:
            - Mapping: Opt PATH => envvar name

        - For each Opt, Argle will look for the envvar and, if found, set
          Opt.envvar accordingly.

    - How arg-parsing will operate:

        - The presence of an upstream input (Opt.pref and Opt.envvar) can help
          satisfy input requirements.

        - The upstream values will go through the usual convert/validate
          process to determine their suitability.

        - The Parser will keep track of data provenance.

        - For each Opt, Argle will use only one source: pref, envar, or ARGS.
          It will not merge/add their inputs together to satisfy quantifiers.

Merging settings and opts:

    - In most situations the user will not have to do anything.
    - The merging will have already occurred during arg-parsing.

    - But for complex situations the user can perform further merging,
      checking, and so forth with access to data-provenance information.

Reporting on data provenance:

    - Data-provenance will be available via the Context.

        opts = p.parse(ARGS)
        sources = opts('sources')

    - Where sources:

        - Is a dict with:
            - key: dest
            - value: Source or dict  # The latter for inner-Results.

        - Each Source will have:

            - source: pref|envvar|default|arg
            - args: the actual ARGS supplying the values.
            - indexes: indexes of those ARGS.

            - Why indexes:
                - Some use cases require knowing the argument ordering.
                - Examples:
                    - Perl `rename`: the "rules" were applied in order.
                    - Unix `find`: ditto.

Why all input sources will go through convert/validate:

    - ARGS and envvars are always simple strings, so they need convert and
      validate.

    - Preferences might seems to need only validate:

        - Yes, a prefs file can contain already-converted types (eg int).
        - But most configs support only basic types (int, float, bool).
        - Basic convert functions can be re-applied without harm.

            int('42') == int(42)

        - And some convert functions will need to return non-basic types.

        - Bottom line: even prefs need convert.

--------
parser-serialization: Parser serialization
--------

In some of my planning notes, I suggested that a configured Parser should be
able to be represented as a regular data structure.

    p1 = Parser(...)
    d1 = p.as_dict

    p2 = Parser(from_dict = d1)

Those notes also implied that the data structure should be serializable:

    - That raises two challenges.

    - Parser data includes callables:
        - Not readily serialized.

    - Parser data has many dataclass instances:
        - Doable.
        - Would need a mechanism to support de-serialization.
        - Maybe a special key holding the dataclass name.

    - Not sure how important serialization really is.
    - Defer this for now.

--------
man-pages-and-argle: Argle and man-pages
--------

Argle will not generate source-syntax for man-pages.

Rationale:

    - Spec-syntax could never achieve what troff can do.

    - Some users might want help-text mimicking man-page design.
    - Argle will aim for approximate mimickry.
        - Documentation that can look generally like a man-page.
        - Achieve this via sections, headings, indentation policy, formatting
          configuration, and so forth.

--------
readme-next-version: README for next version
--------

Check README examples against mockups in examples/argparse-vs-argle.

Move most of the discussion elsewhere:
    - Argle vs alterantives.
    - Motivation.

Argle vs the competitors:
    - Maybe augment the current README
    - Include Click in a future write-up.

Add some default setting to at least one example.

Ultimately, readme should be more how-to than why.

As lib evolves, shorten readme to have very short intro; how to use; then brief
discussion of why its better (maybe bullet points even), with links to longer
discussions of why-build-it and how-it-is-better.

--------------------------------------------------------------------------------
reference: Reference
--------------------------------------------------------------------------------

--------
parsing-resources: Parsing resources
--------

Extended BackusNaur form (EBNF):

    https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form

Recursive descent parser:

    https://en.wikipedia.org/wiki/Recursive_descent_parser

Parsing expression grammar (PEG):

    # Very useful on PEGs, packrat parsing, and CFGs (notes below).
    https://stackoverflow.com/questions/1410477/what-is-packrat-parsing

    https://en.wikipedia.org/wiki/Parsing_expression_grammar

Code examples:

    Pyparsing: https://github.com/pyparsing/pyparsing/

    Build a simple interpreter: https://github.com/rspivak/lsbasi

    http://jayconrod.com/posts/37/a-simple-interpreter-from-scratch-in-python-part-1

Books:

    Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages

--------
parsing-process-generally: Parsing process generally
--------

Given a grammar, generate an appropriate parser.

Given input text, use a lexer to generate typed tokens.

Feed the tokens into the parsers, which determines validity and returns a
syntax tree.

--------
pegs-cfgs-and-packrat-parsing: PEGs, CFGs, and packrat parsing
--------

Resource:

    https://stackoverflow.com/questions/1410477/what-is-packrat-parsing

Many parsers use context-free grammars (CFG). For example:

    E -> E * E | E + E | (E) | N
    N -> D | DN
    D -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

    Rule 1: nonterminal E can be replaced E * E, etc.
    Rule 2: nonterminal N can be replaced by D or DN.
    Rule 3: nonterminal D can be replaced by any single digit.

    The rules can generate any simple arithmetic expression using +, *, parens,
    and single digits.

CFGs are a compact way to represent a collection of strings and they have a
rich and well-understood theory. However, they have two main drawbacks.

    - A CFG defines a collection of strings, but doesn't tell you how to check
      check a string for validity. This means that whether a particular CFG
      will lend itself to a nice parser depends on the particulars of how the
      parser works, meaning that the grammar author may need to familiarize
      themselves with the internal workings of their parser generator to
      understand what restrictions are placed on the sorts of grammar
      structures can arise.

    - Grammars can be ambiguous. For example, the above grammar generates the
      string 2 + 3 * 4, but does so in two ways. In one way, we essentially get
      the grouping 2 + (3 * 4), which is what's intended. The other one gives
      us (2 + 3) * 4, which is not what's meant. This means that grammar
      authors either need to ensure that the grammar is unambiguous or need to
      introduce precedence declarations auxiliary to the grammar to tell the
      parser how to resolve the conflicts. This can be a bit of a hassle.

Parsing expression grammars (PEG) are alternatives to CFGs. Here's the same
arithmetic example in PEG form:

    E -> F + E | F
    F -> T * F | T
    T -> D* | (E)
    D -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 / 9

A key feature of PEGs is explicit ordering of parsing alternatives. The syntax
can be read as "First try this, then this, etc". In that sense, PEGs directly
encode into the grammar structure itself how the parsing is to be done. This
approach resolves the ambiguity noted above and lends itself toward direct
translation from grammar to parser generation.

The Packrat Parsing Algorithm builds on the PEG approach. The algorithm is
conceptually quite simple. At a high level, a packrat parser begins with the
start symbol, then tries the ordered choices, one at a time, in sequence until
it finds one that works. As it works through those choices, it may find that it
needs to match another nonterminal, in which case it recursively tries matching
that nonterminal on the rest of the string. If a particular choice fails, the
parser backtracks and then tries the next production.

The algorithm combines the PEG approach with memoization (essentially dynamic
programming without the bookkeeping) to achieve linear performance.

--------
grammar-types: Grammar types
--------

References:

    https://en.wikipedia.org/wiki/Chomsky_hierarchy
    https://en.wikipedia.org/wiki/Formal_grammar
    https://stackoverflow.com/questions/14589346/is-c-context-free-or-context-sensitive
    https://www.quora.com/What-is-an-intuitive-way-to-describe-the-differences-between-context-sensitive-context-free-and-regular-grammars-Explanations-with-examples-relating-to-human-language-would-be-particularly-helpful

Formal grammars:

    In formal language theory, a grammar describes how to form strings from a
    language's alphabet (or elemental values) that are valid according to the
    language's syntax.

    More specically, a grammar consists of:

        - A finite set N of nonterminal symbols (disjoint from the strings
          formed from G).

        - A finite set T of terminal symbols (disjoint from N).

        - A finite set P of production rules for rewriting strings via
          substitution.

    A grammar is usually thought of as a language generator. However, it can
    also sometimes be used as the basis for a recognizer -- a function in
    computing that determines whether a given string belongs to the language or
    is grammatically incorrect. To describe such recognizers, formal language
    theory uses separate formalisms, known as automata theory.

    Parsing is the process of recognizing an utterance (a string in natural
    languages) by breaking it down to a set of symbols and analyzing each one
    against the grammar of the language.

    Most languages have the meanings of their utterances structured according
    to their syntaxa practice known as compositional semantics. As a result,
    the first step to describing the meaning of an utterance in language is to
    break it down part by part and look at its analyzed form (known as its
    parse tree in computer science, and as its deep structure in generative
    grammar).

Chomsky Hierarchy:

    The following table summarizes each of Chomsky's four types of grammars, the
    class of language it generates, the type of automaton that recognizes it, and
    the form its rules must have.

    Grammar | Languages              | Recognizer automaton       | Allowed production rules
    -----------------------------------------------------------------------------------
    Type-3  | Regular                | Finite state               | A   => a | aB
    Type-2  | Context-free           | Non-deterministic pushdown | A   => x
    Type-1  | Context-sensitive      | LB-ND Turing machine       | xAy => xzy
    Type-0  | Recursively enumerable | Turing machine             | z   => x

    Symbols and abbreviations:

        * These symbols are not standard. Typically, uppercase are terminals,
          lowercase are non-terminals, and Greek are sequences of either.

        a     | Terminal
        ---------------------------------------------
        M     | Non-terminal
        N     | Same
        ---------------------------------------------
        x     | Sequence of terminals or non-terminals
        y     | Same
        z     | Same, and this one cannot empty
        ---------------------------------------------
        LB-ND | Linear-bounded non-deterministic

    Understanding the production rules:

        - Regular grammar (Type-3) is very rigid. Every non-terminal produces
          at least a left-side terminal. The automaton requires no memory and
          can make each decision based on the information directly at hand.

            Classic example (using regex quantifier notation):

                L = a{n}

                X = ''
                X = a
                X = Xa

            In other words, the language consisting of all strings of
            consisting of zero or more letter a.

        - Context-free grammar (Type-2) is more open: a non-terminal can
          generate sequences of terminals and/or non-terminals. The constraint
          is that every non-terminal maps to exactly one pre-defined thing.
          Mappings never change dynamically during parsing. This automaton
          requires memory to support backtracking (classically, a stack).

            Classic example:

                L = a{n} b{n}

                X = ''
                X = ab
                X = aXa
                X = bXb

            To recognize strings in this language, the parser needs to remember
            how many letter a were seen.

        - Context-sensitive (Type-1) can be understood in relation to
          context-free. If you look only at the middle terms, you see the
          context-free production rule just discussed (A => z). But now what
          each non-terminal maps to can differ depending on the context (x and
          y are the surrounding context on both sides of the rule).

            Classic example:

                L = a{n} b{n} c{n}

            At first, I did not understand why this is any different than a{n}
            b{n}. Couldn't you just remember N in the same way? Perhaps the
            answer lies less in the ordinary practicalities of how one would
            implement a real parser but in writing the grammar rules.

        - Context-sensitive (Type-0) is wide open, no constraints on the
          grammar.

--------
other-tools: Other tools
--------

App::Cmd

    - Conclusion: not sure that I'm sold on this.

    - The documentation is difficult.

    - The module uses Params::Validate and Getopt::Long::Descriptive, and it
      does not appear to be flexible in that regard.

Getopt::Long::Descriptive

    - Front end for Getopt::Long

    - Promising in several respects.

    - One could write a subclass to modify help text output.

    - But it does not support the basic element of a option arg name (eg
      --logfile PATH)

    - So subclassing will take you only so far.

    - Supports concept of "implies": if -X, then -Y and -Z are required.

    - Support concept of a hidden option (not in help text).

Getopt::Tabular

    - Tabular spec definition

    - Validation

    - Help text: not bad, but not controllable

    - Can parse an array besides ARGV

    - Looks unmaintained.

Getopt::Lucid:

    - Interesting approach

    - Emphasizes readability of specification

    - Uses a chainable module when defining specs

    - Also allows you to merge options with config

    - Does not produce help text

Getopt::Euclid

    - Creates parser from your application's POD, specifically:

    - The POD can also include validation assertions.

    - Still active.

    - Takes input from @ARGV and puts results in %ARGV

    - I don't like the fact that it uses globals and is non-OO

Getopt::Simple

    - Wrapper around Getopt::Long

    - Produces help text.

Getopt::Declare

    - Builds option parser from a help-text string

    - It's an interesting idea.

    - Requires a special syntax to define the spec and that syntax is embedded
      in the help string

Other Perl modules briefly checked:

    - Abridged
    - Auto
    - Base
    - Chain
    - Clade
    - Compac
    - Complete::Args
    - Easy
    - Fancy
    - Flex
    - Helpful
    - Lazy
    - LL
    - OO
    - Param
    - Plus
    - Regex
    - Tiny
    - Usaginator
    - Params::Validate
    - Params::Smart
    - Getargs::Mixed
    - Getargs::Long
    - Pod::WikiDoc

Pod::Usage

    - You document your application with POD.

    - Then you simply use  Getopt::Long and PodUsage.

    - In addition to getting a usage message, you get a man page (based on
      pod2man) and your application is CPAN-ready.

    - As a result, you have a decent level of control over the look of the
      usage and help text. To the extent that you can't control appearance, at
      least your documentation looks standard.

    - When you invoke pod2usage, you can specify a verbosity level, which
      controls the POD sections that are rendered.

    - The main drawback is POD itself.

    - You could wrap the module to simplify usage further: trap the WARN from
      GetOptions and invoke your own help(); then invoke pod2usage if --help or
      --man are requested.

MooseX::GetOpt

    - Front end for Geopt::Long
    - Requires using Moose
    - Not many new ideas here

Python plac module

    - This module wraps argparse.

    - It deduces the needed parser based on: the signature of the main()
      function (for positional arguments); annotations of the main() function
      (for options).

    - Advertises itself as being super easy to use and setup, but by the time
      you create all of the awkward-looking annotations, it seems like argparse
      would have been simpler.

Ruby Trollop

    - Very simple to use

    - Not much customizability.

Python argparse module

    - Important concept: the module should parse/validate arguments or options

Python's docopt:

    - Primary ideas: (1) write good usage text and build opt parser from it.
      and (2) parsing should be separate from validation.

    - Tried to use it, but seems half-baked:

        - The parsing code is up to the task of achieving goal of infering
          complex logic and arg/option interdependencies from a usage text).

        - It's easy to cause their demo example (naval-fate) to fail just by
          making a few obvious changes to the configuration.

    - Fundamental problem with separating arg parsing from data validation.

        - Because docopt does not validate, it lacks the concept like
          argparse's `choices`.

        - As a result, a library focused on giving the user clear usage text
          has no mechanism for telling the user what the allowed values are for
          an option-argument.

        - It does not even try: in the face of invalid input, it just prints
          the usage text and exits.

    - The library also has an awkward way of creating the returned opts
      dictionary, with keys like `--foo` and `<path>`.

    - The library's returned dict also divorces an option's presence (a
      True/False flag) from the value of its argument. For example, a spec like
      `-C PATH` would produce a dict like `{'-C': True, 'PATH', '/tmp/blah'}`.
      That seems like a fundamental problem.

Python: Click

    - Summary:

        - Interesting but opinionated and therefore rigid in various ways.

        - Strong subcommand support but very weak grammar support:
            - Built around a subcommand model (with nesting).
            - With a heavy focus on dispatching.
            - No grammar support other than:
                - Basic.
                - Commands and nested subcommands.
            - Missing:
                - More than one positional with non-static nargs.
                - Alternatives and mutual exclusion.
                - Groups as first-class grammatical entities.
                - Rich quantifiers.

        - Highly constrained help text:
            - Very little customization of help text.
            - Usage text lists options generically (absent subclassing).

        - Code readability is poor:
            - Configuration ends up scattered across decorators.
            - Not easy to understand script usage at a glance.

        - Heavy API burden:
            - A lot of API to learn just for the documentation's main examples.
            - A API is even more sprawling as you read through the details.

        - Reasonably good support for:
            - Using configuration files as defaults.
            - Ditto for environment variables.
            - Smart-types for conversion/validation.
            - Various utilities adjacent to command-line scripts.
            - But the project seems to be comingling concerns too much.

    - Click views command-line programs through the lens of subcommands:
        - Subcommands can be nested under other subcommands.
        - Other than than, grammatical support is weak (worse than argparse).

    - Click thinks dispatching is a primary concern:
        - I have never felt that way about writing scripts.
        - Dispatching is typically one of the easiest things to do.
        - The dispatching model seems rigid:
            - Always passes 3 arguments to the receiving functions.
            - Function signatures have to align with the arguments
              that will be passed to them.

    - Click explicitly rejects customizability of help output:
        - You can control metavars (like argparse).
        - Usage-text uses a general metavar (OPTIONS) for all options.
        - Overriding that can be done (maybe) with awkward subclassing.

    - Configuration is not very readable:
        - It ends up spread across various decorators.
        - Not easy to understand script usage at a glance of the code.
        - A good example of this is the docopt naval-fate example.
        - In docopt, you can understand usage immediately in the source code.
        - The same example in the Click documentation is much less intuitive.

    - Heavy API burden:
        - If your program fits the Click model well, you can get things working
          rapidly enough.
        - Anything outside that path leads to:
            - Large API footprint.
            - Conceptual and API complexity.
            - Some quite strange API features.
        - In spite of good/extensive documentation, my eyes often glazed over.
        - Examples:
            - Multi Commands.
            - Complex Applications (a git clone).

    - Click explicitly rejects fuzzy option/choice matching:
        - Example: accepting --fu for --fubb if former yields 1 match.
        - The rationale is that accepting fuzzy matches can break future usages
          if end-users get accustomed to the abbreviated options.
        - But the library does support case-insensitivity for situations
          involving Opt.choices, seemingly contrtacting that rationale.

    - Options:
        - Must take a fixed N of parameters (seems restrictive).
        - One exception to that:
            - An option taking 1 parameter can be configured also take zero.
            - Strange.
        - An option's parameters can have different types and (maybe)
          validation.

    - Positionals:
        - A positional can have a fixed nargs.
        - Or it can have nargs of -1, which means 1+ (odd).
        - But only one Opt can be "variadic".

    - Help text details:
        - Help text for commands/subcommands:
            - Set in function docstring.
            - Each command can be given a short_help.
            - If so, Click will document the commands in style similar to
              documentation for options.
        - Help text for an options:
            - Set when defining the Opt via the decorator.
        - Help text for a positionals:
            - Mostly not supported.
            - You have to document them in your command docstring.
            - The small exception here is short_help for commands (see above).
        - Epilog help text:
            - Similar to argparse.
            - Fairly limited in functionality.
        - Metavars in help text:
            - Click supports them, similar to argparse.
            - Also can be applied to all options for a command.
            - Metavar defaults:
                - Parameters: UPPERCASE.
                - All options for a command: OPTIONS.
        - Wrapping:
            - Syntax to suppress default wrapping is quite opaque.
            - Syntax to include non-help-text in a function docstring is also weird.

    - Support for configuration files and environment variables:
        - Click has a reasonable and flexible approach.
        - At least within the larger limits of the system.
        - But the API footprint is moderately large.

    - Supports eager options (like priority Opts).

    - Supports file handling and various other smart types:
        - Meaning types that carry additional requirements for
          convert/validate.

    - Testing support:
        - Has some support for running your Click commands in testing
          scenarios.
            - Capturing stdout/stderr.
            - Using an isolated file system.
        - I did not read carefully and am skeptical that it can do very much.

    - Shell completion:
        - Refer to Click documentation when setting up completion for Argle.
        - I did not read closely.
        - Completion seems to be supported only for scripts executed via an
          entry point in setuptools.

    - Other utilities:
        - Provides an echo() function.
            - More robust in the face of Unicode issues.
            - Works across various terminal environments.
        - Also support for:
            - ANSI coloring.
            - Pagination.
            - Screen clearing.
            - Getting single character inputs from end-user.
            - Waiting for key press.
            - Launching editors.
            - Launching other applications.
            - Showing progress bars.
        - All of that is cool/useful in some sense.
            - But why combine it with a command-line argument parser?
            - Seems like too much comingling of concerns.

Python invoke:

    - Part of the Fabric ecosystem.

    - Good for a collection of small tools used by a project.

    - Not a full CLI arg parser.

Ruby Thor

    - Similar to Fabric in its approach.

Ruby GLI

--------
problems-scenarios-from-argparse: Problems scenarios from argparse
--------

https://stackoverflow.com/questions/35847084

    Wants to customize help text capitalization to mimic standard English usage
    for section titles. The answers demostrate the absurdity of trying to
    customize argparse help text.

        Usage: ...                       # Difficult: must subclass.

        Positional arguments:            # Fairly easy: ap._positionals.title
            ...

        Optional arguments:              # Fairly easy: ap._optionals.title
            ...

https://stackoverflow.com/questions/18025646

    Grammar needed:

        frob -x [other-opts]
        frob -y -z [other-opts]

https://stackoverflow.com/questions/4466197

    Grammar needed:

        frob [ -s | -f [-m] ] <host>
        frob -h

https://stackoverflow.com/questions/28660992

    Grammar needed:

        - Option takes 2 args.
            - The 1st arg must be A|B|C.
            - The 2nd arg must be X|Y|Z.

        frob [-a {A,B,C} {X,Y,Z}]
        frob -h

    Solvable if the parser allows `choices` to take a list:

        dict(
            option = '-a',
            nargs = 2,
            choices = [(A, B, C), (X, Y, Z)],
        )

https://stackoverflow.com/questions/25626109

    Grammar needed: if -x if present, -a and -b are also required.

        frob          [-y] [-z]
        frob -x -a -b [-y] [-z]

http://bugs.python.org/issue11588

    Grammar needed:

        - Sets of arguments that must occur together.

        frob -o           [-x]
        frob -r (-p | -s) [-x]

    Grammar needed:

        frob -a -b [-x]
        frob -c -d [-x]

http://bugs.python.org/issue10984

    Grammar needed:

        - User has three flags: -a -b -c
        - Plus some other flags: -x -y
        - The -b flag is incompatible with both -a and -c.

        frob [-b]      [-x] [-y]
        frob [-a] [-c] [-x] [-y]

https://stackoverflow.com/questions/11455218

    Grammar needed:

        - If -y is given, -x is required.

        frob [-x] [-z]
        frob -y -x [-z]

https://stackoverflow.com/questions/27681718

    Grammar needed:

        frob [-x] [-y] (<a> <b> <c>)...

    Approach:

        - Allow groups of positionals to be repeated, with append-like action.

https://stackoverflow.com/questions/19114652

    Grammar needed:

        - The entire CLI grammar can be repeated.

        frob (version <n> --file <p1> <p2>)...

    Control how choices are listed in usage text:

        - eg, don't repeat them.

            -n {foo,bar,baz}, --name {foo,bar,baz}

        - or refer to them by name, and then define the name later

            --othername FOO

            where FOO
                foo
                bar
                baz

Help text with subparsers:

    frob -h
        - some people want just top-level help
        - others want all help : top-level all subparsers

https://stackoverflow.com/questions/4042452

    If program has required args/options, but it is run
    with zero args, provide help text, not error text.

    It's trivial if you have a grammar:

        frob <x> <y> [-z]
        frob --help
        frob

https://stackoverflow.com/questions/27258173

    - Required: -x, -y, or both (but not neither).

    frob -x [-y] [-z]
    frob -y [-x] [-z]

https://stackoverflow.com/questions/5257403

    - wants nargs to allow a range: eg, 1 to 3.

    - this works, but starts to look ugly if N gets larger

        frob -x A [B [C]]

        frob -x A [B [C [D [E [F]]]]]

    - other possibilities:

        frob -x A...{7}
        frob -x A...{1,3}
        frob -x A...{0,3}
        frob -x A...{3,}

https://stackoverflow.com/questions/4692556

    Need just the literal 'all' or 1+ positions.

    frob [-x] [-y] all
    frob [-x] [-y] <pos>...

https://stackoverflow.com/questions/62524681

    - Wants a grammar where each -C option resets the configuration,
      and where the specifically declared configurations are linked
      to the -p option.

    - The desired end result is a list of configurations.

    frob -w 100 -c 50 -C -w 1000 -c 500 -p /foo -C -w 5% -c 3% -p /bar
         ----(3)-----    ---------(1)----------    --------(2)--------

    1. Configuration for the /foo volume.
    2. Ditto, for /bar volume.
    3. Configuration settings for all other volumes.

job-client:

    Allow for extra options for job-client devs, based on env var.

    Special options that exit-with-msg (without griping about other issues):
        --version
        --examples
        --autocomplete

    General and task-specific help (without griping about other issues):
        job-client -h
        job-client TASK -h
        job-client -h TASK -h

    Using a YAML config file:

        - Settings from the config file should control the `default`
          settings for the argument parser.

        - When running `job-client configure`, you do not want to load the
          existing config file.

--------
example-grammars: Example grammars
--------

Example 1:

    [-b]      [-x] [-y]   # -a and -b are mutex,
    [-a] [-c] [-x] [-y]   # and -b also allows -c

Example 2:

    [-x]  [-z] <a>
    -y -x [-z] <a> [<b>]   # If -y, then -x is required and <b> is allowed.

Example 3:

    [-x] [-y] (<a> <b> <c>)...

Example 4:

    (-x | -y | -z -q) [-a] <b>

Example 5:

    (-a -x | -b... | [-a] -c -d) [-e | -f] [-g] <h> [<i>...] ([-j -k]... | -m -n)

--------
argparse-problems: Examples of problems with argparse
--------

Argparse fails with a positional with choices taking 0+ inputs.

    - Example:

        import argparse
        p = argparse.ArgumentParser()
        p.add_argument('letter', nargs = '*', choices = ['a', 'b'])
        opts = p.parse_args()
        print(opts)

    - Error if you supply zero arguments:

        error: argument letter: invalid choice: [] (choose from 'a', 'b')

    - It will do the right thing if you convert the positional to an option:

        p.add_argument('--letter', nargs = '*', choices = ['a', 'b'])

    - It will also do the right thing if you drop choices and do the
      choices-validation yourself.

        p.add_argument('letter', nargs = '*')

    - Possible fix coming in Python 3.14

        https://github.com/python/cpython/issues/53834

--------
project-name: Project name: history and alternatives
--------

Previous name:
    - Optopus.
    - Change to Argle: 2025-05-10
    - Reason: too frequently mistyped, misspoken, and misremembered.

Names considered:

    - Discussion with ChatGPT:

        https://chatgpt.com/share/6817a2e4-0928-8003-8489-6f5950e69915

    - Top candidates after that process:

        Argle
        Optopus
        Wizcat
        Argzilla
        Bargle

    - Liked but difficult to say.

        Argvark

    # Liked but already taken in pypi, github, or both.

        Argonaut
        Argspec
        Argyle
        Cliopt
        Cmdy
        Optcat
        Optix
        Optoid
        Specio

